<resources>
    <string name="app_name">코틀린 공부</string>
    <string name="image_description">모바일 애플리케이션의 아이콘</string>
    <string name="version">Ver 1.0</string>
    <string name="setting_name">설정</string>

    <string name="intro_menu_name">애플리케이션 소개</string>
    <string name="intro_menu">소개</string>
    <string name="menu_1">1. 코틀린이란?</string>
    <string name="menu_1_1">1.1. 개요</string>
    <string name="menu_1_2">1.2. 주요 특징</string>
    <string name="menu_2">2. 코틀린 기초 문법</string>
    <string name="menu_2_1">2.1. 시작하기(Hello, World!)</string>
    <string name="menu_2_2">2.2. 변수(Variables)</string>
    <string name="menu_2_3">2.3. 자료형(Data Types) 기초</string>
    <string name="menu_2_4">2.4. 표준 입출력</string>
    <string name="menu_2_5">2.5. 연산자 종류</string>
    <string name="menu_2_6">2.6. 문, 식, 블록</string>
    <string name="menu_3">3. 제어 구조</string>
    <string name="menu_3_1">3.1. if-elseif-else</string>
    <string name="menu_3_2">3.2. when</string>
    <string name="menu_3_3">3.3. 범위 값 비교</string>
    <string name="menu_3_4">3.4. 스마트 캐스트</string>
    <string name="menu_3_5">3.5. while</string>
    <string name="menu_3_6">3.6. for</string>
    <string name="menu_3_7">3.7. break</string>
    <string name="menu_3_8">3.8. continue</string>
    <string name="menu_4">4. 예외 처리</string>
    <string name="menu_4_1">4.1. try-catch-finally</string>
    <string name="menu_4_2">4.2. throw</string>
    <string name="menu_4_3">4.3. try 식</string>
    <string name="menu_5">5. 문자열</string>
    <string name="menu_5_1">5.1. 문자열 선언</string>
    <string name="menu_5_2">5.2. 주요 프로퍼티 및 메소드</string>
    <string name="menu_5_3">5.3. 문자열 순회</string>
    <string name="menu_5_4">5.4. 이스케이프 문자</string>
    <string name="menu_5_5">5.5. 정규 표현식</string>
    <string name="menu_6">6. 배열</string>
    <string name="menu_6_1">6.1. 배열 생성</string>
    <string name="menu_6_2">6.2. 원시 타입의 배열</string>
    <string name="menu_6_3">6.3. 배열 순회</string>
    <string name="menu_6_4">6.4. 다차원 배열</string>
    <string name="menu_6_5">6.5. 주요 프로퍼티 및 메소드 1</string>
    <string name="menu_6_6">6.6. 주요 프로퍼티 및 메소드 2</string>
    <string name="menu_6_7">6.7. 배열 정렬</string>
    <string name="menu_7">7. 함수</string>
    <string name="menu_7_1">7.1. 함수 정의</string>
    <string name="menu_7_2">7.2. 이름 붙인 인자</string>
    <string name="menu_7_3">7.3. 디폴트 파라미터 값</string>
    <string name="menu_7_4">7.4. 최상위 함수</string>
    <string name="menu_7_5">7.5. 확장 함수</string>
    <string name="menu_7_6">7.6. 가변 인자 함수</string>
    <string name="menu_7_7">7.7. 중위 함수</string>
    <string name="menu_8">8. 객체 지향 프로그래밍</string>
    <string name="menu_8_1">8.1. 클래스 기초</string>
    <string name="menu_8_2">8.2. 커스텀 접근자</string>
    <string name="menu_8_3">8.3. 게터와 세터</string>
    <string name="menu_8_4">8.4. 인터페이스</string>
    <string name="menu_8_5">8.5. 상속 관련 변경자</string>
    <string name="menu_8_6">8.6. 가시성 변경자</string>
    <string name="menu_8_7">8.7. 내부 클래스와 중첩 클래스</string>
    <string name="menu_8_8">8.8. sealed 클래스</string>
    <string name="menu_8_9">8.9. 주 생성자</string>
    <string name="menu_8_10">8.10. 부 생성자</string>
    <string name="menu_8_11">8.11. data 클래스</string>
    <string name="menu_8_12">8.12. by 키워드</string>
    <string name="menu_8_13">8.13. object 키워드</string>
    <string name="menu_8_14">8.14. enum 클래스</string>
    <string name="menu_9">9. 컬렉션(Collections)</string>
    <string name="menu_9_1">9.1. 읽기 전용 vs 변경 가능</string>
    <string name="menu_9_2">9.2. List</string>
    <string name="menu_9_3">9.3. Set</string>
    <string name="menu_9_4">9.4. Map</string>
    <string name="menu_10">10. 람다 식</string>
    <string name="menu_10_1">10.1. 람다 기초</string>
    <string name="menu_10_2">10.2. 멤버 참조</string>
    <string name="menu_10_3">10.3. 컬렉션 함수</string>
    <string name="menu_10_4">10.4. 시퀀스(Sequence)</string>
    <string name="menu_10_5">10.5. 함수형 인터페이스</string>
    <string name="menu_10_6">10.6. Scope 함수</string>
    <string name="menu_11">11. null</string>
    <string name="menu_11_1">11.1. null 이 될 수 있는 타입</string>
    <string name="menu_11_2">11.2. 안전한 호출 연산자(?.)</string>
    <string name="menu_11_3">11.3. 엘비스 연산자(?:)</string>
    <string name="menu_11_4">11.4. 캐스트 연산자(as)</string>
    <string name="menu_11_5">11.5. !! 연산자</string>
    <string name="menu_11_6">11.6. let 함수</string>
    <string name="menu_11_7">11.7. lateinit 키워드</string>
    <string name="menu_11_8">11.8. 타입 확장</string>
    <string name="menu_12">12. 코틀린 타입</string>
    <string name="menu_12_1">12.1. 원시 타입과 래퍼 클래스</string>
    <string name="menu_12_2">12.2. 타입 변환</string>
    <string name="menu_12_3">12.3. Any</string>
    <string name="menu_12_4">12.4. Unit</string>
    <string name="menu_12_5">12.5. Nothing</string>
    <string name="menu_13">13. 연산자 오버로딩</string>
    <string name="menu_13_1">13.1. operator 키워드</string>
    <string name="menu_13_2">13.2. 산술 연산자 오버로딩</string>
    <string name="menu_13_3">13.3. 비교 연산자 오버로딩</string>
    <string name="menu_13_4">13.4. 인덱스 연산자 오버로딩</string>
    <string name="menu_13_5">13.5. in 연산자 오버로딩</string>
    <string name="menu_14">14. 고차 함수</string>
    <string name="menu_14_1">14.1. 함수 타입</string>
    <string name="menu_14_2">14.2. 함수를 인자로 받는 함수</string>
    <string name="menu_14_3">14.3. 함수를 반환하는 함수</string>
    <string name="menu_14_4">14.4. 인라인 함수</string>
    <string name="menu_14_5">14.5. noinline 변경자</string>
    <string name="menu_14_6">14.6. crossinline 변경자</string>
    <string name="menu_15">15. 제네릭스</string>
    <string name="menu_15_1">15.1. 타입 파라미터</string>
    <string name="menu_15_2">15.2. 제네릭 함수와 프로퍼티</string>
    <string name="menu_15_3">15.3. 제네릭 클래스</string>
    <string name="menu_15_4">15.4. 타입 파라미터 제약</string>
    <string name="menu_15_5">15.5. 지워진 타입 파라미터</string>
    <string name="menu_15_6">15.6. reified</string>
    <string name="menu_15_7">15.7. 무공변성</string>
    <string name="menu_15_8">15.8. 공변성</string>
    <string name="menu_15_9">15.9. 반공변성</string>

    <string-array name="intro_content">
        <item>
            " 프로그래밍 언어 중 하나인 코틀린의 기초 문법에 대해 설명하는"
            "앱입니다. 화면 위의 툴바에서 좌측 아이콘을 클릭하여 코틀린"
            "문법을 학습할 수 있습니다. 각 문서에는 코틀린 문법에 대한"
            "설명과 문제들을 확인하실 수 있습니다. 각 설명은 책 \'Kotlin"
            "IN ACTION\'을 참고하였습니다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_1_1">
        <item>
            " 코틀린은 JVM(Java Virtual Machine)에서 동작하는 객체 지향"
            "프로그래밍 언어이다. 2011년에 JetBrains 에서 공개하였으며,"
            "자바(Java)와의 상호 운용성을 중시한다. 자바와의 상호 운용이"
            "100% 지원되기 때문에 대부분 자바가 사용되는 곳에서 코틀린을"
            "활용할 수 있으며, 주로 서버와 안드로이드 앱 개발에 사용된다."
            "또한 기존 자바 라이브러리를 활용할 수 있다. 2017년 구글은"
            "코틀린을 안드로이드 앱 개발 공식 언어로 추가하였다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_1_2">
        <item>
            "1. 정적 타입(Statically Typed) 지정 언어\n\n"

            " 코틀린은 자바와 마찬가지로 정적 타입 지정 언어이다. 정적 타입"
            "지정 언어에 대해 설명하기 앞서 동적 타입(Dynamically Typed)"
            "지정 언어에 대해 설명하자면, 동적 타입 지정 언어는 타입과 관계없이"
            "모든 값을 변수에 넣을 수 있고, 메소드나 필드를 실행 시점에 검증하기"
            "때문에 코드의 길이가 짧아지고 유연한 데이터 구조를 생성할 수 있다."
            "하지만 오타 같은 실수를 컴파일 시점에 검증할 수 없기 때문에 실행"
            "시점에 오류가 발생하여 프로그램이 중단될 가능성이 높아진다. 이에"
            "비해 정적 타입 지정 언어는 컴파일 시점에 모든 프로그램 구성 요소의"
            "타입을 알 수 있다. 변수의 타입이나 메소드의 반환 타입 등을 컴파일러가"
            "컴파일 시점에 검증하기 때문에 실행 시점에 프로그램이 오류로 중단될"
            "가능성이 적다. 코틀린이 자바와 다른 점은 타입을 명시하지 않아도"
            "컴파일러가 문맥을 통해 변수 타입을 자동으로 유추할 수 있다. 이런"
            "기능을 타입 추론(Type Inference)라고 한다.\n\n\n\n"



            "2. 간결성\n\n"

            " 다른 객체 지향 프로그래밍 언어와 비교하면 코드의 길이를 줄일"
            "수 있어 코드가 더 간결하다. 예를 들어, 클래스를 생성할 때 필요한"
            "게터(getter), 세터(setter), 생성자 파라미터를 필드에 대입하는"
            "코드, toString 메소드, equals 메소드 등의 준비 코드를"
            "작성하지 않아도 코틀린에서는 자동으로 생성해준다. 예를 들어,"
            "코틀린으로 Student 클래스를 작성할 때의 코드 길이를 자바와"
            "비교하면 다음과 같다. 위의 코드가 자바로 작성한 코드, 아래가 코틀린으로"
            "작성한 코드이다.\n"
        </item>
        <item>
            "\n\n3. 안정성\n\n"

            "다음 자바 코드를 확인해보자.\n\n"
        </item>
        <item>
            "\n 위의 함수는 문자열의 길이를 반환하는 함수이다. 그런데 이 코드는"
            "안전하다고 볼 수 없다. 그 이유는 String 타입의 변수 str 에 문자열 뿐만"
            "아니라 null 을 전달할 수 있고, null 을 전달하면 str.length() 에서"
            "NullPointerException 이 발생하기 때문이다.\n"
            "코틀린은 컴파일 시점에 null 이 될 수 없는 값을 검사하여 실행 시점에"
            "NullPointerException 이 발생하는 코드를 금지한다. 위의 자바 코드를"
            "코틀린으로 다음과 같이 작성할 수 있다.\n"
        </item>
        <item>
            "\n 코틀린 컴파일러는 위의 코틀린 코드에서 파라미터에 null 값을 전달하는"
            "것을 방지한다. 따라서 실행 시점에 NullPointerException 이 발생하지"
            "않는다.\n\n\n\n"



            "4. 상호운용성\n\n"

            " 코틀린은 JVM(Java Virtual Machine)에서 동작하는 언어로 자바와"
            "100% 상호 운용된다. 코틀린은 자바 라이브러리를 그대로 사용할 수"
            "있으며, 자바 메소드를 호출하거나 자바 클래스를 상속하는 등 코틀린에서"
            "자바 코드를 사용할 수 있고, 그 반대도 가능하다.\n\n\n\n"



            "5. 함수형 프로그래밍과 객체 지향 프로그래밍\n\n"

            " 코틀린은 자바와 같은 객체 지향 프로그래밍 언어이면서 동시에 함수형"
            "프로그래밍이 가능하도록 지원한다. 예를 들어, 코틀린은 람다 식을 지원하며,"
            "불변 값 객체를 생성할 수 있고, 함수를 변수에 저장할 수 있으며, 함수를"
            "인자로 받거나 함수를 결과로 반환하는 고차 함수를 지원한다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_2_1">
        <item>
            " 프로그래밍 언어를 배울 때 첫 번째 단계인 \"Hello, World!\"를 출력하는"
            "프로그램을 코틀린으로 작성하면 다음과 같다.\n"
        </item>
        <item>
            "\n 해당 코드를 분석하자면 다음과 같다\n\n"

            "(1):\n"
            " 첫 번째 줄은 주석을 나타내며, 소스 코드를 쉽게 이해할 수"
            "있도록 하는 메모 역할을 한다. 주석은 코틀린 컴파일러에 의해 무시되어"
            "프로그램에 영향을 미치지 않는다. 주석 작성 방법은 자바와"
            "동일하다.\n\n"

            "(2):\n"
            " 두 번째 줄의 fun 키워드는 함수를 선언할 때 사용한다.\n\n"

            "(3):\n"
            " main 함수는 프로그램의 시작점이 되는 부분이다.\n\n"

            "(4):\n"
            " args: Array&lt;String&gt; 에서 args 는 파라미터이고,"
            "Array&lt;String&gt; 은 파라미터의 타입이다."
            "자바와 달리 코틀린에서는 타입을 뒤에 작성한다.\n\n"

            "(5):\n"
            " println 함수는 \"Hello, World!\" 문자열을 출력하기 위해"
            "사용되었다.\n\n"

            "(6):\n"
            " 자바와 달리 줄 끝에 세미콜론(;)을 넣지 않는다.\n"
            "세미콜론을 넣어도 오류는 나지 않는다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_2_2">
        <item>
            " 변수는 특정 값을 저장하는 메모리 주소에 붙이는 이름이다. 모든"
            "변수는 사용되기 전에 선언되어야 한다. 변수를 선언하기 위해서는"
            "변수에 저장할 값의 타입과 변수 이름을 지정해야 한다. 변수 이름은"
            "LowerCamelCase 방식을 따르는 것이 관습이다. 변수를 선언하는"
            "방법은 다음과 같다.\n"
        </item>
        <item>
            "\n 위의 코드에서 age 는 변수 이름이고, Int 는 변수 타입을 의미한다."
            "등호 뒤에 오는 24는 변수 age 에 저장하는 값을 의미한다. 변수"
            "타입이 이름 앞에 오는 자바와 달리 코틀린에서는 타입이 이름 뒤에"
            "온다. 또 다른 차이점으로는 코틀린에서는 타입을 생략할 수 있다."
            "다음 예제를 보자.\n"
        </item>
        <item>
            "\n 첫 번째 예제와는 달리 변수 타입을 명시하지 않았지만, 컴파일러는"
            "이 코드를 분석해서 변수 age 에 24라는 값이 초기화된 것을 확인하여"
            "변수 age 의 타입이 Int 타입임을 추론한다. 이를 타입 추론(Type Inference)"
            "라고 한다. 단, 반드시 초기화 식을 사용해야만 타입 추론이 이루어진다."
            "초기화 식을 사용하지 않는다면 변수에 저장된 값이 없기 때문에 타입"
            "추론을 할 정보가 없어서 타입 추론을 할 수 없다. 따라서 초기화 식을"
            "사용하지 않고 변수를 선언하려면 반드시 타입을 명시해야 한다.\n"
        </item>
        <item>
            "\n 한편, 변수 이름 앞에 존재하는 val 키워드는 변수 선언 시 사용하는"
            "키워드이다. 변수 선언 시 사용하는 키워드는 총 2가지가 존재한다.\n\n\n"


            "(1) val:\n"
            " 자바의 final 변수에 해당하는 키워드로, 일단 변수에 값이"
            "저장된 뒤에는 재대입을 할 수 없음을 의미한다. 값을 뜻하는"
            "value 에서 유래되었다.\n\n"

            "(2) var:\n"
            " 자바의 일반 변수에 해당하는 키워드로, 변수에 값이 저장된 후"
            "나중에 값을 변경할 수 있음을 의미한다. 변수를 뜻하는"
            "variable 에서 유래되었다.\n\n\n"


            "주의할 점으로 val 변수라 할지라도 그 변수가 참조하는 객체의"
            "내부 값은 변경될 수 있다는 점이다. 예를 들어 다음 예제는"
            "올바른 코드이다.\n"
        </item>
        <item>
            "\n 위의 예제에서 val 변수로 선언된 nums 변수는 ArrayList 객체이고"
            "초기화될 때 1이라는 값만 가지고 있었지만, nums.add(2) 라는 코드를"
            "통해 2라는 값이 추가되었다. 이렇듯 val 변수도 내부 값은 변경될 수"
            "있다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_2_3">
        <item>
            " 코틀린에는 크게 2가지 타입이 존재한다. 하나는 원시 타입(Primitive Type)이고,"
            "다른 하나는 참조 타입(Reference Type)이다. 원시 타입의 변수에는"
            "값이 직접 들어가지만, 참조 타입의 변수에는 메모리에 존재하는 객체의"
            "주소가 들어간다는 차이점이 있다. 코틀린의 원시 타입의 종류는 다음과"
            "같다. 자바와 달리 첫 문자가 대문자임을 주의하자.\n\n"

            "1. 정수 타입\n"
        </item>
        <item>"\n\n2. 실수 타입\n"</item>
        <item>"\n\n3. 문자 타입\n"</item>
        <item>"\n\n4. 논리 타입\n"</item>
    </string-array>

    <string-array name="explanation_2_4">
        <item>
            "1. 표준 출력(Standard Output)\n\n"

            " 정수나 문자열 같은 데이터를 출력하기 위해 사용하는 표준 출력 함수에는"
            "print, println 함수가 있다. print 함수는 자바의"
            "System.out.print 함수와 같고, println 함수는 자바의"
            "System.out.println 함수와 같다. 다음은 표준 출력 함수를"
            "사용하는 코틀린 예제이다.\n"
        </item>
        <item>
            "\n 위의 예제에서 알 수 있듯이, print 함수는 출력을 한 뒤"
            "줄 바꿈을 하지 않지만, println 함수는 출력을 한 뒤 다음"
            "줄로 넘어간다.\n\n\n\n"



            "2. 표준 입력(Standard Input)\n\n"

            " 키보드 같은 입력장치를 통해 데이터를 입력받기 위해 readLine"
            "메소드를 사용하거나 Scanner 클래스를 사용할 수 있다. readLine"
            "메소드를 사용하여 표준 입력을 받는 방법은 다음과 같다.\n"
        </item>
        <item>
            "\n 위의 코드에서 입력받은 값을 변수 input 에 저장한 뒤 출력하였다."
            "이 때, 변수를 문자열 내에 출력하기 위해 문자열 템플릿(String Template)을"
            "사용하였다. 변수 앞에 $를 붙여 '$변수명' 방식으로 출력할 수 있고,"
            "가독성을 위해 변수를 중괄호({})로 감싸서 '${변수명}' 방식으로 출력할 수 있다."

            "\n\n 표준 입력을 받는 다른 방법으로 Scanner 클래스를 사용하는"
            "방법이 있다. Scanner 클래스를 사용하기 위해선 먼저 Scanner"
            "클래스를 import 해야 한다. Scanner 클래스를 사용하는 방법은"
            "다음과 같다.\n"
        </item>
        <item>
            "\n 위의 코드에서 자바와 다른 점은 System.`in` 이다. "
            "자바에서는 System.in 으로 사용하지만, 코틀린에서는 in 이"
            "코틀린에서 사용하는 예약어이기 때문에 ` `으로 감싸서 사용한다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_2_5">
        <item>"1. 산술 연산자"</item>
        <item>
            "\n\n\n2. 비교 연산자\n\n"

            " 자바에서 == 연산자는 참조 타입의 변수를 비교할 때 주소 값을 비교하는"
            "것과 달리, 코틀린에서는 == 연산자가 내부적으로 equals 메소드를"
            "호출한다. 즉, 두 참조 타입 변수의 저장된 값을 비교한다. 두 참조 타입"
            "변수의 주소 값을 비교하려면 === 연산자를 사용하면 된다.\n"
        </item>
        <item>"\n\n\n3. 복합 대입 연산자\n"</item>
        <item>"\n\n\n4. 증감 연산자\n"</item>
        <item>"\n\n\n5. 논리 연산자\n"</item>
        <item>"\n\n\n6. 비트 연산자\n"</item>
        <item>"\n\n\n7. 부호 연산자\n"</item>
    </string-array>

    <string-array name="explanation_2_6">
        <item>
            "1. 문(Statement)\n\n"

            " 문(Statement)은 프로그래밍에서 어떤 작업을 실행하는 최소 문법 단위를"
            "의미한다. 하나의 프로그램은 여러 개의 문으로 구성된다. 자바에서 문은"
            "항상 세미콜론(;)으로 끝나지만, 코틀린에선 선택 사항이다. 코틀린에서"
            "변수 선언이나 변수에 값을 대입하는 것은 모두 문이다.\n\n\n\n"



            "2. 식(Expression)\n\n"

            " 식(Expression)은 최소 하나의 값을 반환하며 다른 식의 하위 요소로"
            "계산에 참여할 수 있다. 반면, 문(Statement)은 자신을 둘러싸고 있는"
            "가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다."
            "코틀린에서 모든 함수는 식이다. 또한, 자바에서는 모든 제어 구조가 문인"
            "반면에 코틀린에서는 반복문을 제외한 대부분의 제어 구조가 식이다.\n\n\n\n"



            "3. 블록(Block)\n\n"

            " 블록(Block)은 중괄호({})로 감싸진 코드 부분을 의미한다."
            "블록은 여러 개의 문으로 구성될 수 있고, 내부에 여러 개의 블록을"
            "포함할 수 있다.\n\n\n\n"



            "4. 식이 본문인 함수\n\n"

            " 함수 본문이 중괄호({})로 둘러싸인 함수를 블록이 본문인 함수라"
            "한다. 반면에 등호와 식으로 구성된 함수를 식이 본문인 함수라"
            "한다. 함수 본문이 하나의 식으로만 이루어져 있는 경우, 중괄호({})와"
            "return 을 없애고 식 앞에 등호를 붙여서 식이 본문인 함수로 표현할"
            "수 있다. 다음은 하나의 식으로만 구성된 블록이 본문인 함수를"
            "식이 본문인 함수로 변환하는 방법을 보여준다.\n"
        </item>
        <item>
            " 위의 식이 본문인 함수에서 반환 타입을 생략할 수 있다. 생략하더라도"
            "컴파일러가 함수 본문 식을 분석해서 반환 타입을 추론할 수 있다. 이런"
            "기능을 타입 추론(Type Inference)라고 한다. 주의할 점으로,"
            "식이 본문인 함수만 반환 타입을 생략할 수 있다. 블록이 본문인 함수에선"
            "반드시 반환 타입을 지정하고 return 문을 사용해야 한다."
        </item>
    </string-array>

    <string-array name="explanation_3_1">
        <item>
            " 코틀린에서 반복문을 제외한 대부분의 제어 구조는 식이다. 식은"
            "문과 달리 최소 하나의 값을 반환할 수 있다는 차이점이 있다. 코틀린의"
            "if 는 자바와 거의 같다. 조건식이 참일 때만 if 본문이 실행된다."
            "else if 는 이전 분기의 조건식이 거짓일 때만 실행되며, else 는"
            "모든 분기의 조건식이 거짓일 때만 실행된다. 자바와 다른 점은"
            "자바의 if 와 달리 코틀린의 if 는 값을 반환할 수 있다. 코틀린에서 if 를"
            "어떻게 사용하는지 알아보자.\n\n\n\n"



            "1. if\n\n"

            " 코틀린의 if 는 자바와 거의 같다. 조건식이 참일 때만 if 본문이"
            "실행된다."
        </item>
        <item>
            "2. if-else\n\n"

            " else 는 모든 분기의 조건식이 거짓일 때만 실행된다. 자바와"
            "달리 코틀린의 if 는 값을 반환할 수 있다. 값을 반환할 수 있기"
            "때문에 자바와 달리 삼항 연산자가 존재하지 않는다. 자바의 삼항"
            "연산자를 코틀린의 if-else 로 표현하면 다음과 같다. 자바와"
            "마찬가지로 각 분기에 식이 하나 밖에 없기에 중괄호를 생략할 수 있다."
        </item>
        <item>
            " 만약 if 분기에 블록을 사용하는 경우 그 블록의 마지막 식이 그 분기의"
            "값이 된다."
        </item>
        <item>
            "3. else if\n\n"

            " else if 는 이전 분기의 조건식이 거짓일 때만 실행된다."
        </item>
        <item>
            " else if 는 여러 개 존재할 수 있다. 다만 분기가 여러 개"
            "존재하는 경우 if 중첩보다는 when 을 사용하여 코드를 다듬을"
            "수 있다. when 은 3.2.절에서 설명한다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_3_2">
        <item>
            "1. when 사용법\n\n"

            " 코틀린의 when 은 자바의 switch 문을 대체하면서도"
            "더 다양한 기능을 제공한다. 코틀린의 if 가 값을 반환할 수 있는"
            "것처럼 when 도 값을 반환할 수 있는 식이다. 코틀린의 when 을"
            "사용하는 예제는 다음과 같다.\n"
        </item>
        <item>
            " 위의 예제에서 when 은 인자로 받은 값과 같은 분기를 찾는다."
            "맞는 분기를 찾아내면 그 분기를 실행하고, 찾아내지 못하면 else"
            "분기를 실행한다. 자바와 달리 각 분기의 끝에 break 을 넣지 않아도"
            "된다.\n\n\n\n"



            "2. 인자 없는 when\n\n"

            " 자바의 switch 문은 반드시 인자가 필요하다. 이와 달리 코틀린의"
            "when 은 인자 없이 사용할 수 있다. 인자 없는 when 을 사용하려면"
            "각 분기의 조건이 Boolean 결과를 반환하는 식이어야 한다. 인자"
            "없는 when 을 사용하는 예제는 다음과 같다.\n"
        </item>
        <item>
            "3. 한 분기 안에 여러 값 사용하기\n\n"

            " 한 분기 안에 여러 값을 사용하기 위해선 그 값들을 콤마(,)로"
            "분리하면 된다.\n"
        </item>
    </string-array>

    <string-array name="explanation_3_3">
        <item>
            " 코틀린의 조건식은 인자로 받은 값이 특정 범위 안에 포함되는지"
            "확인할 수 있다. in 연산자를 사용하면 특정 범위 안에 포함되는지"
            "확인할 수 있고, !in 연산자를 사용하면 특정 범위 안에 없는지"
            "확인할 수 있다. 다음은 변수 value 에 저장된 값이 어떤 특정"
            "범위에 포함되는지 확인하는 예제이다.\n"
        </item>
        <item>
            " 위의 예제에서 .. 연산자는 시작 값과 끝 값을 연결하여 범위를"
            "만든다. 코틀린에서 범위는 시작 값과 끝 값을 포함하는 구간,"
            "즉 폐구간이다. 예를 들어 0..5 은 0 과 5 을 포함하는 범위를"
            "만든다. 즉 0, 1, 2, 3, 4, 5 의 수열을 의미한다. 주의할 점은"
            "처음 값이 5 가 아니라 0 이라는 점이다. 5 부터 시작해서"
            "0 으로 끝나는 수열은 \'5 downTo 0\' 이다. 또한 1 씩 변화하는"
            "것이 아니라 n 씩 변화하는 수열을 원한다면 범위 뒤에 step n 을"
            "작성하면 된다. 예를 들어 1, 3, 5, 7, 9, 수열은"
            "\'1..9 step 2\' 이다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_3_4">
        <item>
            " 코틀린에서는 is 를 사용해 변수 타입을 확인한다. 코틀린의 is 는"
            "자바의 instanceof 와 비슷하다. 차이점이 있다면 자바에서는"
            "instanceof 로 변수의 타입을 확인한 뒤에 명시적으로 타입"
            "캐스팅을 해야 하지만, 코틀린에서는 is 로 타입을 확인하면"
            "컴파일러가 자동으로 캐스팅을 해준다는 점이다."
            "이를 스마트 캐스트(Smart Cast)라고 한다.\n"
        </item>
    </string-array>

    <string-array name="explanation_3_5">
        <item>
            " 코틀린의 while 은 자바의 while 루프와 동일하다. 마찬가지로"
            "코틀린의 do-while 루프도 자바의 do-while 루프와 동일하다."
        </item>
    </string-array>

    <string-array name="explanation_3_6">
        <item>
            " 코틀린의 for 루프는 자바의 for-each 루프와 동일한 것만"
            "존재한다. 코틀린의 for 루프는 주로 컬렉션에 대한 이터레이션에"
            "많이 사용된다. 코틀린의 for 루프를 사용하는 방법은 다음과 같다.\n\n\n\n"



            "1. 범위에 대한 이터레이션\n"
        </item>
        <item>"\n\n\n\n2. 문자열에 대한 이터레이션\n"</item>
        <item>"\n\n\n\n3. 배열에 대한 이터레이션\n"</item>
        <item>"\n\n\n\n4. 컬렉션에 대한 이터레이션\n"</item>
    </string-array>

    <string-array name="explanation_3_7">
        <item>
            " 코틀린의 break 는 자바의 break 와 같다.\n\n\n\n"



            "1. Unlabelled break\n"
        </item>
        <item>"\n\n\n\n2. Labelled break\n"</item>
    </string-array>

    <string-array name="explanation_3_8">
        <item>
            " 코틀린의 continue 는 자바의 continue 와 같다.\n\n\n\n"



            "1. Unlabelled continue\n"
        </item>
        <item>"\n\n\n\n2. Labelled continue\n"</item>
    </string-array>

    <string-array name="explanation_4_1">
        <item>
            " 코틀린의 예외 처리는 자바와 크게 다르지 않다. 자바와 마찬가지로"
            "예외 처리를 위해 try, catch, finally 을 사용한다.\n"
        </item>
        <item>
            " 자바와 다른 점은 throws 가 코드에 없다는 점이다. 자바에서는"
            "함수를 작성할 때 함수 선언 뒤에 throws 을 붙여야 하지만,"
            "코틀린에서는 붙이지 않는다."
        </item>
    </string-array>

    <string-array name="explanation_4_2">
        <item>
            " throw 키워드는 예외를 발생시킬 때 사용한다. 아래 예제는"
            "양수를 입력받는 함수로, 음수를 받았을 경우 예외를 발생시키는"
            "코드이다.\n"
        </item>
        <item>
            " 또한 자바와 달리 throw 는 식으로 사용할 수 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_4_3">
        <item>
            " 코틀린의 try 는 자바와 달리 식으로 사용할 수 있다. if 식과 달리"
            "try 의 본문을 중괄호({})로 감싸야 한다는 점을 주의하자. try 본문의"
            "마지막 식이 결과 값이 되며, 예외가 발생한 경우 catch 본문의 마지막"
            "식이 결과 같이 된다.\n"
        </item>
        <item>
            " 입력 값이 7일 때:\n"
        </item>
        <item>
            "\n\n 입력 값이 7.7일 때:\n"
        </item>
    </string-array>

    <string-array name="explanation_5_1">
        <item>
            " 코틀린의 문자열은 자바의 문자열과 유사하다. 문자열을 선언하기"
            "위해선 큰따옴표(\" \")를 사용하면 된다. 문자열 변수를 선언하는"
            "방법은 다음과 같다.\n"
        </item>
        <item>
            " 위의 코드와 같이 큰따옴표(\" \")를 사용해서 단일 문자열을"
            "선언하거나 3중 큰따옴표(\"\"\" \"\"\")를 사용해서 여러 줄로"
            "이루어진 문자열을 선언할 수 있다. 또한 문자열은 클래스에 해당하기"
            "때문에 String() 을 사용해서 문자열을 선언할 수 있다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_5_2">
        <item>
            " 이번 절에서는 코틀린 문자열의 주요 프로퍼티 및 메소드를 알아보자.\n\n\n\n"



            "1. 문자열 길이: length\n"
        </item>
        <item>
            "\n\n\n\n\n\n2. 문자 추출: get 메소드\n"
        </item>
        <item>
            " 위의 예제에서 str[2] 는 str.get(2) 와 동일하다."
            "문자열에서 [ ] 를 통한 접근은 get 메소드를 호출한다.\n\n\n\n\n\n"





            "3. 문자열 비교: equals 메소드\n"
        </item>
        <item>
            " 위의 예제에서 equals 메소드 호출은 == 로 접근하는 것과"
            "같다. 문자열에서 == 을 통한 접근은 equals 메소드를 호출한다."
            "자바와 달리 코틀린에서는 참조 타입의 변수를 비교할 때 == 사용은"
            "두 변수의 주소를 비교하는 것이 아니라 두 변수의 값을 비교한다."
            "만약 두 참조 타입 변수의 주소를 비교하고 싶다면 === 을 사용하면"
            "된다.\n\n\n\n\n\n"





            "4. 부분 문자열: substring or subSequence 메소드\n"
        </item>
        <item>
            " 위의 예제에서 substring 와 subSequence"
            "메소드는 부분 문자열을 반환한다. 두 메소드의 유일한 차이점은"
            "반환 타입이 다르다는 점이다. substring 메소드는 String"
            "타입의 값을 반환하지만, subSequence 메소드는 CharSequence"
            "타입의 값을 반환한다.\n\n\n\n\n\n"





            "5. 문자열 위치: indexOf 메소드\n"
        </item>
        <item>
            " 위의 예제에서 indexOf 메소드는 인자로 넘긴 문자열의"
            "시작 위치의 인덱스를 반환한다. 만약 인자로 넘긴 문자열이 포함되어"
            "있지 않을 경우, -1 을 반환한다.\n\n\n\n\n\n"





            "6. 문자열 포함 여부 확인: contains 메소드\n"
        </item>
        <item>
            "\n\n\n\n\n\n7. 문자열 교체: replace 메소드\n"
        </item>
        <item>
            " replace 메소드는 문자열을 직접 수정하는 것이 아니라"
            "새로운 문자열을 반환한다. 이는 String 객체의 문자열이 변경"
            "불가능한 특성을 갖기 때문이다.\n\n\n\n\n\n"





            " 문자열을 분리할 때 사용할 때 사용하는 split 메소드는"
            "5.5 절에서 다룬다. 문자열 관련 메소드는 너무 많기 때문에 여기에서는"
            "자주 쓰이는 메소드만 살펴보았다. 나머지는 다음 주소에서 확인할 수 있다.\n\n"
        </item>
        <item>
            "https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/"
            "\n\n"
        </item>
    </string-array>

    <string-array name="explanation_5_3">
        <item>"1. 인덱스를 통한 문자열 순회\n"</item>
        <item>
            "\n\n\n\n\n\n2. for 루프를 이용한 문자열 순회\n\n"

            " for 루프는 이터레이터(iterator)를 제공하는 모든 것에"
            "대해 이터레이션을 할 수 있다.\n"
        </item>
        <item>"\n\n\n\n\n\n3. forEach()\n"</item>
        <item>
            " forEach 표준 함수는 모든 원소에 대해 람다를 호출한다."
            "여기서 it 은 str 의 각 원소를 반환한다. 람다나 it 에 대해선"
            "10.1 절에서 설명한다. forEach 을 사용하면 기존의 반복문과 달리"
            "continue 와 break 을 쓸 수 없다는 점을 주의하자.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_5_4">
        <item>
            " 이스케이프 문자(Escape Characters)는 문자열 내에서"
            "사용하는 특별한 기능을 수행하는 문자이다. 이스케이프 문자를 사용하면"
            "문자열 내에 특정 문자를 포함시킬 수 있거나 문자열 출력을 제어할 수"
            "있다. 이스케이프 문자는 역슬래시로 시작한다는 특징이 있다."
            "이스케이프 문자의 종류는 다음과 같다.\n"
        </item>
    </string-array>

    <string-array name="explanation_5_5">
        <item>
            " 정규 표현식은 특정한 규칙을 가진 문자열을 찾기 위해 사용되는"
            "형식 언어이다. 코틀린에서는 Regex 클래스를 통해 정규 표현식을"
            "지원한다. 코틀린에서 정규 표현식을 어떻게 사용하는지 알아보자.\n\n\n\n"


            "1. 메타 문자\n\n"

            " 정규 표현식을 사용하기 위해 알아두어야 할 메타 문자의 종류는"
            "다음과 같다.\n"
        </item>
        <item>
            "2. 정규 표현식 객체 생성\n\n"

            " 정규 표현식 객체를 생성하는 방법은 아래와 같이 3가지가 있다.\n"
        </item>
        <item>
            "\n\n\n3. find 메소드\n\n"

            " find 메소드는 해당 정규 표현식과 일치하는 부분 중 첫 번째를"
            "반환한다.\n"
        </item>
        <item>
            "\n\n\n\n4. findAll 메소드 \n\n"

            " findAll 메소드는 해당 정규 표현식과 일치하는 모든 부분을"
            "반환한다."
        </item>
        <item>
            "\n\n\n\n5. 문자열 분리\n\n"

            " split 메소드는 문자열을 분리하기 위해 사용한다. 문자열을"
            "분리하기 위해 기준이 되는 문자열이 필요한데 이 때 정규 표현식을"
            "사용한다. 다음은 정규 표현식을 이용해 문자열을 분리하는 예제이다.\n"
        </item>
        <item>
            "\n\n 위의 예제는 공백 문자 , 콤마(,) , - , _ 로 이루어진 문자열을"
            "기준으로 문자열을 분리한다. 위의 예제처럼 정규 표현식을 사용해서"
            "문자열을 분리할 수 있지만, 간단한 경우에는 구분 문자열을 하나 이상"
            "인자로 넘겨서 분리할 수도 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_6_1">
        <item>
            " 배열은 동일한 타입의 여러 원소들로 이루어진 자료 구조를 의미한다."
            "코틀린의 배열은 다른 프로그래밍 언어와 크게 다르지 않다. 연속된"
            "메모리 공간에 저장되고, 인덱스로 각 요소에 접근할 수 있으며, 배열의"
            "크기는 고정되어 있다. 이번 절에서는 코틀린에서 배열을 만드는 방법에 대해"
            "알아보도록 한다.\n\n\n\n"



            "1. Array 생성자\n"
        </item>
        <item>
            "\n\n 위의 코드에서 0부터 9까지의 정수로 이루어진 배열을 생성하였다."
            "Array 생성자를 통해 배열을 생성하려면 배열 크기와 초깃값을"
            "지정해야 한다. 위에서 ( ) 안의 숫자가 배열의 크기를 의미하고,"
            "람다로 초깃값을 지정하였다. 람다를 사용하는 방법은 10.1 절에서 다룬다."
            "또한 변수를 선언할 때 타입 추론을 이용할 수 있듯이, 배열을 생성할 때도"
            "타입 추론을 이용할 수 있다. 위의 배열은 정수로만 이루어져 있으므로"
            "타입을 생략하더라도 컴파일러가 타입을 추론해준다. 따라서 다음 코드도"
            "올바른 코드이다.\n"
        </item>
        <item>
            "\n\n\n\n2. arrayOf()\n\n"

            " Array 생성자를 사용하지 않고 arrayOf 을 사용하여 원소를"
            "넘겨서 배열을 만들 수 있다.\n"
        </item>
        <item>
            "\n\n\n\n3. arrayOfNulls()\n\n"

            " arrayOfNulls 에 배열 크기와 타입을 인자로 넘기면"
            "모든 원소가 null 인 인자로 넘긴 크기와 같은 배열을 생성할"
            "수 있다. arrayOfNulls 은 타입 추론을 할 수 없으므로"
            "타입을 반드시 넘겨야 한다.\n"
        </item>
    </string-array>

    <string-array name="explanation_6_2">
        <item>
            "코틀린에는 원시 타입의 배열을 표현하는 클래스가 존재한다. 예를 들어"
            "Int 타입의 배열은 IntArray 이고, Boolean 타입의 배열은"
            "BooleanArray 이다. 모든 원시 타입의 배열은 각각 자바"
            "원시 타입의 배열인 int[ ], double[ ], boolean[ ] 등으로"
            "컴파일된다. 원시 타입의 배열을 만드는 방법은 다음과 같다.\n\n\n\n"



            "1. 생성자를 이용하는 방법\n\n"

            " 각 원시 타입 배열의 생성자를 이용해 원시 타입의 배열을 만들 수"
            "있다. 배열의 크기만 인자로 넘기면 해당 원시 타입의 디폴트 값으로"
            "초기화된 배열을 생성할 수 있다.\n"
        </item>
        <item>
            "\n 배열의 크기 뿐만 아니라 람다를 인자로 넘기면 초깃값을 지정할 수 있다.\n"
        </item>
        <item>
            "2. 팩토리 함수를 이용하는 방법\n\n"

            " 각 원시 타입의 배열이 제공하는 팩토리 함수를 이용해 원시 타입의"
            "배열을 생성할 수 있다. 가변 인자로 여러 개의 값을 넘겨서 배열을"
            "만들 수 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_6_3">
        <item>"1. 인덱스를 이용한 배열 순회\n"</item>
        <item>"\n\n\n\n2. for 루프를 이용한 배열 순회\n"</item>
        <item>"\n\n\n\n3. forEach()\n"</item>
    </string-array>

    <string-array name="explanation_6_4">
        <item>
            " 다른 프로그래밍 언어와 마찬가지로 코틀린에서도 배열 안에 또 다른"
            "배열을 저장함으로써 다차원 배열을 생성할 수 있다. 예를 들어"
            "2차원 배열은 다음과 같이 생성할 수 있다.\n\n\n "
        </item>
    </string-array>

    <string-array name="explanation_6_5">
        <item>
            " 이번 절에서는 코틀린 배열의 주요 프로퍼티 및 메소드를 알아보자.\n\n\n\n"


            "1. 배열 길이: size\n"
        </item>
        <item>
            "\n\n\n\n2. 배열 원소의 인덱스: indexOf 메소드\n\n"

            " 인자로 값을 넘기면 그 값과 동일한 첫 번째 원소의 인덱스를"
            "반환한다. 존재하지 않으면 -1 을 반환한다.\n"
        </item>
        <item>
            "\n\n\n\n3. 배열 원소의 합: sum 메소드\n\n"

            " 정수 또는 실수 타입의 배열의 경우 sum 메소드를 이용하면"
            "쉽게 원소의 합을 구할 수 있다.\n"
        </item>
        <item>
            "\n\n\n\n4. 배열 원소의 평균: average 메소드\n\n"

            " 정수 또는 실수 타입의 배열의 경우 average 메소드를 이용하면"
            "쉽게 원소의 평균값을 구할 수 있다. 반환 타입은 Double 이다.\n"
        </item>
        <item>
            "\n\n\n\n5. 배열의 첫 번째 원소: first 메소드\n"
        </item>
        <item>
            "\n\n\n\n6. 배열의 마지막 원소와 인덱스: last 메소드, lastIndex\n"
        </item>
        <item>
            "\n\n\n\n7. 원소 찾기: find 와 findLast 메소드\n\n"

            " 인자에 람다식을 넘기면 그 조건에 해당하는 원소를 반환한다."
            "find 메소드는 첫 번째 원소를, findLast 메소드는 마지막 원소를"
            "반환한다. 존재하지 않으면 null 을 반환한다.\n"
        </item>
    </string-array>

    <string-array name="explanation_6_6">
        <item>
            "8. 원소 개수: count 메소드\n\n"

            " 두 가지 사용법이 있다. 하나는 인자 없이 count 메소드를"
            "호출하는 것으로, size 프로퍼티와 동일하게 배열 원소의 개수를"
            "반환한다. 다른 하나는 람다 식을 인자로 넘기는 것으로, 해당 조건과"
            "일치하는 원소의 개수를 반환한다.\n"
        </item>
        <item>
            "\n\n\n\n9. 원소 포함 여부: contains 메소드\n"
        </item>
        <item>
            "\n\n\n\n10. 최댓값과 최솟값: maxOrNull 와 minOrNull 메소드\n\n"

            " 최댓값을 구하려면 maxOrNull 메소드를, 최솟값을 구하려면"
            "minOrNull 메소드를 사용하면 된다. 두 메소드 모두 배열 내에"
            "원소가 존재하지 않으면 null 을 반환하며, 원소 내에 NaN 가"
            "존재할 경우 NaN 을 반환한다.\n"
        </item>
        <item>
            "\n\n\n\n11. 배열 뒤집기: reverse 메소드\n\n"

            " 두 가지 사용법이 있다. 하나는 인자 없이 reverse 메소드를"
            "호출하는 것으로, 배열 내의 모든 원소를 역순으로 재배치한다. 다른"
            "하나는 시작 인덱스와 끝 인덱스를 인자로 넘기는 것으로, 시작 인덱스부터"
            "끝 인덱스 이전까지의 원소들을 역순으로 재배치한다.\n"
        </item>
        <item>
            "\n\n\n\n12. 문자열로 변환: joinToString 메소드\n"
        </item>
        <item>
            "\n\n\n\n13. 부분 배열: sliceArray 메소드\n"
        </item>
    </string-array>

    <string-array name="explanation_6_7">
        <item>
            " 코틀린 배열 정렬 방법은 기본적으로 오름차순, 내림차순으로 정렬하는"
            "방법이 있으며, 람다 식이나 Comparator 을 인자로 넘겨 정렬하는"
            "방법 등 여러 가지가 있다. 또한 원본 배열에 대해 정렬하거나,"
            "정렬된 배열을 반환할 수 있다. 코틀린 배열 정렬 방법은 다음과 같다.\n\n\n\n"



            "1. 원본 배열에 대한 정렬\n\n"

            " sort 메소드는 원본 배열을 오름차순으로, sortDescending"
            "메소드는 내림차순으로 정렬한다. 인자로 아무 것도 넘기지 않으면"
            "배열 전체를 정렬하고, 시작 인덱스와 끝 인덱스를 인자로 넘기면"
            "시작 인덱스부터 끝 인덱스 이전까지의 부분만 정렬한다.\n"
        </item>
        <item>
            "\n\n\n\n2. 정렬된 배열 반환\n\n"

            " 1. 와 다른 점은 원본 배열을 정렬하는 것이 아니라 정렬된 배열을"
            "반환한다는 점이다. 정렬된 배열을 반환하므로 변수에 저장해야 한다.\n"
        </item>
        <item>
            "\n\n\n\n3. 람다 식을 이용한 정렬\n"
        </item>
        <item>
            "\n\n\n\n4. Comparator 을 이용한 정렬\n"
        </item>
    </string-array>

    <string-array name="explanation_7_1">
        <item>
            " 함수란 특정 기능을 수행하는 코드의 단위를 말한다. 함수를 선언하려면"
            "함수 이름, 반환 타입, 필요한 파라미터를 작성해야 한다. 함수를"
            "사용하는 방법은 다음과 같다.\n\n\n\n"



            "1. 함수 선언\n"
        </item>
        <item>
            "\n 위의 예제에서 함수를 선언하기 위해 fun 키워드를 사용하였다."
            "함수 이름은 sum 으로 선언하였으며, 파라미터는 Int 타입 3개이다."
            "반환 타입은 함수 선언 뒤에 있는 Int 타입이다. 마지막으로"
            "중괄호({ })로 둘러싸인 부분이 함수 본문이다.\n\n\n\n"



            "2. 식이 본문인 함수\n\n"

            " 함수 본문이 하나의 식으로만 이루어져 있으면 중괄호와 return"
            "을 없애고 식 앞에 등호를 붙여서 식이 본문인 함수로 표현할 수 있다."
            "식이 본문인 함수의 경우 코틀린 컴파일러가 타입 추론을 하므로"
            "반환 타입을 작성하지 않아도 된다. 다음은 1. 예제를 식이 본문인"
            "함수로 변환한 것이다.\n"
        </item>
        <item>
            "\n\n\n\n3. 함수 호출\n\n"

            " 함수를 호출하려면 호출하고자 하는 함수에 필요한 파라미터를 순서대로"
            "넘기면 된다.\n"
        </item>
    </string-array>

    <string-array name="explanation_7_2">
        <item>
            " 이름 붙인 인자란 함수를 호출할 때 인자 앞에 파라미터 이름을"
            "붙인 것을 말한다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 joinToString 메소드는 배열이나 컬렉션 내의"
            "원소들을 하나의 문자열로 만든다. 예제에서 두 번째 joinToString"
            "메소드를 호출한 부분에서 이름 붙인 인자를 사용하였다. 이름 붙인 인자는"
            "함수를 호출할 때 함수에 전달하는 인자 전부 또는 일부에 사용할 수"
            "있다. 이름 붙인 인자를 사용함으로써 인자를 넘길 때 각 인자가 어떤"
            "역할을 하는지 쉽게 구분할 수 있다. 주의할 점으로 어느 하나라도"
            "이름을 명시하면 그 뒤에 오는 인자들도 이름을 반드시 명시해야 한다.\n"
            " 참고로 IntelliJ IDEA 를 사용하는 경우, 함수를 호출할 때"
            "인자의 이름을 자동으로 추적해준다. 실제로 위의 예제에서 첫 번째"
            "joinToString 메소드를 사용할 때 이름이 표시되었다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_7_3">
        <item>
            " 디폴트 파라미터 값이란 인자로 값을 넘기지 않았을 때 파라미터"
            "값으로 사용되는 디폴트 값을 의미한다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 sum 함수를 호출할 때 마지막 인자를 생략할 수 있다."
            "30 이라는 디폴트 파라미터 값이 있기 때문에 인자를 넘기지 않으면"
            "자동으로 파라미터 c 에는 30 이 저장된다. 반면에 a 와 b 는"
            "디폴트 파라미터 값이 존재하지 않기 때문에 인자를 넘기지 않으면"
            "오류가 발생한다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_7_4">
        <item>
            " 자바에서 모든 함수는 클래스 내부에 존재해야 한다. 반면에"
            "코틀린에서는 함수를 클래스 밖에 선언할 수 있다. 클래스 없이"
            "존재하는 함수를 최상위 함수라고 한다. 7.1 ~ 7.3 절에서"
            "다룬 모든 함수는 최상위 함수이다. 클래스를 생성하지 않고 사용할 수"
            "있다는 점에서 자바의 static 유틸리티 클래스를 대체할 수 있다."
            "코틀린은 static 을 지원하지 않기 때문에 최상위 함수로 정적"
            "메소드를 대체하면 된다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_7_5">
        <item>
            " 확장 함수란 어떤 클래스의 멤버 메소드인 것처럼 사용할 수 있지만"
            "클래스 밖에서 선언된 함수를 의미한다. 확장 함수를 사용하면 외부"
            "라이브러리가 제공하는 클래스에 새로운 메소드를 추가할 수 있다."
            "일반적으로 다른 사람이 만든 외부 라이브러리를 사용할 때 그 라이브러리를"
            "수정하기 어렵지만, 코틀린에서 제공하는 확장 함수 기능을 사용하면"
            "외부 라이브러리 자체를 변경하지 않고도 새로운 함수를 추가할 수"
            "있다. 예를 들어 문자열의 두 번째 문자를 반환하는 메소드를 추가한다고"
            "하면 다음과 같이 작성할 수 있다.\n"
        </item>
        <item>
            "\n\n\n\n"
            " 확장 함수를 생성하기 위해서는 추가하려는 함수 이름 앞에 그 함수가"
            "추가될 클래스의 이름을 지정하면 된다. 클래스 이름은 수신 객체"
            "타입(Receiver Type)이라고 하며, 확장 함수가 호출되는"
            "대상이 되는 값을 수신 객체(Receiver Object)라고 한다."
            "위의 예제에서 수신 객체 타입은 String 이고, 수신 객체는"
            "this 이다. 변수 str 에 대해 확장 함수가 호출되었으므로"
            "this 의 값은 \"Kotlin\" 이다.\n"
            " 일반 메소드 본문에 this 를 사용할 수 있는 것처럼 확장 함수"
            "본문 내에서도 this 를 사용할 수 있다. 또한 일반 메소드 본문에서"
            "this 를 생략할 수 있는 것처럼 확장 함수 본문 내에서도 생략할"
            "수 있다. 따라서 위의 second 확장 함수를 다음과 같이 수정할 수 있다.\n"
        </item>
        <item>
            "\n\n\n\n"
            " 확장 함수는 정의되기만 하면 그 확장 함수가 생성된 소스 파일에서는"
            "자유롭게 사용할 수 있다. 그러나 다른 소스 파일에서 확장 함수를"
            "사용하려면 임포트(import) 해야 한다. 다른 소스 파일에서"
            "임포트하는 방법은 다음과 같다.\n\n"

            "import [확장 함수가 정의된 패키지 이름].[확장 함수 이름]\n\n"

            " as 키워드를 사용하면 임포트한 확장 함수를 다른 이름으로 사용할"
            "수 있다.\n\n"

            "import [패키지 이름].second as two\n"
            "val c = \"Kotlin\".two()\n\n\n\n"


            " 확장 함수를 사용할 때 주의해야 할 점은, 클래스 내의 일반"
            "메소드와 달리 확장 함수에서는 클래스 내부에서만 사용 가능한"
            "private 멤버나 protected 멤버를 사용할 수 없다는 점이다."
            "또한 확장 함수는 정적으로 결정되기 때문에 일반 메소드와 달리"
            "오버라이드(Override) 할 수 없다는 점도 주의하자.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_7_6">
        <item>
            " 여러 개의 Int 타입 변수를 인자로 넘겨 합을 구하는 함수는"
            "어떻게 정의할 수 있을까? 인자로 IntArray 을 넘기는 방법이"
            "있지만 가변 인자 함수를 사용하는 방법도 있다. 가변 인자 함수란"
            "인자의 개수가 달라질 수 있는 함수이다. 가변 인자 함수를 사용하려면"
            "vararg 변경자를 파라미터 앞에 붙이면 된다. 여러 개의 Int"
            "타입 변수의 합을 구하는 가변 인자 함수는 다음과 같다.\n"
        </item>
        <item>
            "\n\n\n\n"
            " 위의 예제처럼 여러 개의 인자를 직접 넘길 수 있지만 배열에"
            "존재하는 값들을 넘길 수 있다. 그럴 경우 스프레드 연산자를"
            "사용해서 배열을 명시적으로 풀어야 한다. 인자로 넘길 배열 앞에"
            "*를 붙이기만 하면 된다. 스프레드 연산자를 사용한 예제는 다음과"
            "같다.\n"
        </item>
    </string-array>

    <string-array name="explanation_7_7">
        <item>
            " 중위 함수 호출이란 인자가 하나 뿐인 함수를 함수 호출 시 사용하는"
            "점(.)과 함수 이름 뒤의 소괄호를 생략하여 호출하는 방법이다."
            "중위 함수를 사용하려면 3가지 조건이 있다. 파라미터가 1개만"
            "존재해야 하며, 멤버 메소드 또는 확장 함수여야 하며, infix"
            "키워드를 사용해야 한다. 중위 함수를 사용하는 예제는 다음과 같다.\n"
        </item>
        <item>
            "\n\n\n\n"
            " 위의 예제에서 squared 함수는 제곱 수를 구하는 함수이다."
            "num.squared(2.5) 처럼 일반적인 함수 호출 방법을 사용할"
            "수 있지만, \'num squared 2.5\' 처럼 중위 호출 구문을"
            "사용할 수 있다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_8_1">
        <item>
            " 이번 절에서는 코틀린으로 어떻게 클래스를 선언하는지 알아본다.\n\n\n\n"



            "1. 클래스 구조\n"
        </item>
        <item>
            "\n 클래스는 일반적으로 위와 같은 구조를 갖는다. 클래스 헤더는"
            "클래스의 파라미터와 생성자를 포함한다. 모든 클래스는 이름을 갖고 있으며,"
            "위에서는 ClassKotlin 이 클래스 이름이다.\n\n\n\n"



            "2. 프로퍼티\n\n"

            " 프로퍼티(Property)란 필드와 접근자를 묶어서 표현하는 개념으로,"
            "코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 완전히 대신한다."
            "프로퍼티는 일반 변수를 선언하는 방법과 마찬가지로 val, var"
            "키워드를 사용한다. val 키워드로 선언한 프로퍼티는 읽기 전용"
            "프로퍼티이며, var 키워드로 선언한 프로퍼티는 변경 가능한 프로퍼티이다."
            "다음 예제를 보자.\n"
        </item>
        <item>
            "\n 코틀린은 값을 저장하는 비공개 필드, 그 필드에 값을 저장하는 세터,"
            "필드의 값을 읽는 게터로 이루어진 디폴트 접근자를 제공한다. 위의"
            "예제에서 name 은 읽기 전용 프로퍼티로, 비공개 필드와 공개 게터를"
            "만들고, age 은 변경 가능한 프로퍼티로, 비공개 필드와 공개 게터,"
            "공개 세터를 만든다.\n\n\n\n"



            "3. 클래스 사용\n"
        </item>
        <item>
            " 클래스를 사용하려면 생성자를 호출해야 한다. 위의 예제의"
            "Student(\"John\", 24) 부분이 생성자에 인자를 넘겨"
            "객체를 생성한 코드이다. 자바와 달리 객체를 생성할 때 new 키워드를"
            "사용하지 않는다. 클래스를 생성하면 클래스의 프로퍼티를 사용할 수"
            "있다. 프로퍼티 이름을 직접 사용해도 게터 또는 세터가 자동으로"
            "호출된다. 프로퍼티 이름에 값을 대입하면 세터가 호출되고, 값을"
            "대입하지 않으면 게터가 호출된다. 또한 val 로 선언한 프로퍼티는"
            "읽기 전용이므로 세터를 호출할 수 없지만, var 로 선언한 프로퍼티는"
            "게터와 세터 모두 호출 가능하다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_8_2">
        <item>
            " 일반적으로 프로퍼티를 생성하면 디폴트 접근자가 자동으로 만들어지지만"
            "디폴트 접근자를 사용하지 않고 직접 프로퍼티의 접근자를 구현할 수"
            "있다. 예를 들어 직사각형 클래스 Square 가 있고 그 클래스에"
            "높이에 해당하는 프로퍼티 height, 너비에 해당하는 프로퍼티"
            "width, 자기 자신이 정사각형인지 확인해주는 프로퍼티"
            "isSquare 가 있다고 가정해보자. isSquare 는 높이와"
            "너비가 같으면 true, 다르면 false 이다. 여기서 커스텀"
            "접근자를 사용하면 별도의 필드에 Boolean 값을 저장할 필요없이"
            "height 와 width 의 값에 접근해서 이 둘을 비교하여"
            "Boolean 값을 반환할 수 있다.\n"
        </item>
        <item>
            " 위의 예제에서 isSquare 프로퍼티는 자체 값을 저장하지 않고"
            "height 와 width 를 비교하는 게터만 존재한다. 또한"
            "게터 get() 의 본문이 하나의 식으로만 이루어져 있으므로 중괄호와"
            "return 을 없애고 등호를 붙여서 간단하게 표현할 수 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_8_3">
        <item>
            " 코틀린의 클래스에서 프로퍼티를 선언하면 게터와 세터가 자동으로"
            "생성된다. val 로 프로퍼티를 선언하면 게터만, var 로 프로퍼티를"
            "선언하면 게터와 세터 모두 자동으로 생성된다.\n"
        </item>
        <item>
            "\n 위의 예제에서 name 프로퍼티는 게터만, age 프로퍼티는 게터와"
            "세터 모두 자동으로 생성된다. 위의 코드는 아래의 코드와 동일하다.\n"
        </item>
        <item>
            "\n get() 은 게터, set() 은 세터를 의미한다. 그리고 게터와"
            "세터에서 사용한 field 은 접근자의 본문에서 필드에 접근할 때"
            "사용한다.\n"
            " 디폴트 게터와 세터를 사용할 수 있지만 게터와 세터를 직접 구현할"
            "수 있다. 예를 들어 게터를 사용할 때 문자열과 함께 출력하거나,"
            "세터를 사용할 때 변경되기 전의 값을 출력할 수 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_8_4">
        <item>
            " 코틀린의 인터페이스는 자바와 다르게 추상 메소드뿐 아니라 구현된"
            "메소드도 선언할 수 있다. 또한 인터페이스 내에 프로퍼티를 선언할"
            "수 있다. 코틀린의 인터페이스를 어떻게 사용하는지 알아보자.\n\n\n\n"



            "1. 인터페이스 선언\n"
        </item>
        <item>
            "\n 인터페이스를 선언하기 위해선 interface 키워드 뒤에 인터페이스"
            "이름을 붙이면 된다. 위의 예제의 인터페이스 이름은 InterfaceKotlin"
            "이다. 그리고 method() 라는 추상 메소드를 선언하였다. 메소드의"
            "본문이 존재하지 않으므로 abstract 키워드를 붙이지 않아도"
            "자동으로 추상 메소드로 선언된다.\n\n\n\n"



            "2. 구현된 메소드와 프로퍼티 선언\n\n"

            " 코틀린 인터페이스 내에는 구현된 메소드와 프로퍼티를 선언할 수"
            "있다. 단, 프로퍼티는 값을 저장할 수 없고 초기화도 불가능하다.\n"
        </item>
        <item>
            "\n\n\n\n3. 인터페이스 구현\n\n"

            " 자바에서는 인터페이스를 구현하기 위해 implements 키워드를"
            "사용하지만, 코틀린에서는 인터페이스를 구현하는 클래스 이름 뒤에"
            "콜론(:)을 붙인 다음 인터페이스 이름을 적는다. 인터페이스 이름을"
            "콜론 뒤에 여러 개 작성하면 여러 개의 인터페이스를 구현할 수 있다.\n"
        </item>
        <item>
            " override 변경자는 상위 클래스나 인터페이스의 프로퍼티나"
            "메소드를 오버라이드할 때 사용한다. 자바와 달리 오버라이드할 때"
            "반드시 override 변경자를 사용해야 한다. 위의 예제에서"
            "인터페이스에서 구현되지 않은 property 와 method1 메소드를"
            "구현하기 위해 override 변경자를 사용하였다.\n\n\n\n"



            "4. super\n\n"

            " 상위 클래스나 인터페이스의 구현된 메소드를 호출하기 위해서는"
            "super 을 사용하면 된다.\n"
        </item>
        <item>
            " 위의 예제처럼 super.[메소드 이름] 형식으로 호출할 수 있다."
            "또는 &lt; &gt; 를 사용해서 기반 티입을 명시적으로 표시할 수"
            "있다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_8_5">
        <item>
            " 자바에서 final 클래스는 다른 클래스가 상속할 수 없는 것처럼"
            "코틀린에서도 마찬가지로 final 클래스는 상속할 수 없다. 또한"
            "final 메소드도 오버라이드할 수 없다. 코틀린의 클래스와 메소드는"
            "기본적으로 final 이기 때문에 오버라이드할 수 없다. 코틀린에서"
            "상위 클래스를 다른 클래스가 상속하는 것을 허용하거나 메소드를"
            "오버라이드하는 것을 허용하려면 open 변경자를 앞에 붙여야 한다.\n"
        </item>
        <item>
            "\n 자바에서 상위 클래스를 하위 클래스가 상속할 경우 extends"
            "키워드를 사용하는 것과 달리, 코틀린에서는 하위 클래스의 이름"
            "뒤에 콜론(:)을 붙인 뒤 상속할 클래스 이름을 적는다. 클래스는"
            "하나만 상속할 수 있다.\n"
            " 클래스를 상속하거나 인터페이스를 구현한 클래스를 하위 클래스가"
            "상속하는 것을 허용할 경우 상위 클래스나 인터페이스의 메소드를"
            "오버라이드했다면 그 메소드는 open 키워드를 붙이지 않아도"
            "기본적으로 open 이다. 오버라이드한 메소드를 하위 클래스에서"
            "오버라이드하지 못하게 하려면 final 키워드를 사용해야 한다.\n"
        </item>
        <item>
            " 클래스 앞에 abstract 키워드를 붙여서 추상 클래스로 선언할"
            "수 있다. 추상 클래스는 인스턴스화할 수 없으며, 하위 클래스에서"
            "상속해야 한다.\n"
        </item>
        <item>
            " 위의 예제에서 abstract 로 선언된 메소드는 반드시 오버라이드해야"
            "한다. abstract 로 선언되었으면 open 을 붙이지 않아도"
            "자동으로 open 이다. 또한 추상 클래스 내의 구현된 메소드는"
            "기본적으로 final 이지만 open 키워드를 붙여 하위 클래스에서"
            "오버라이드할 수 있도록 허용할 수 있다. 인터페이스의 경우 모든 멤버는"
            "open 이며, 메소드의 본문이 존재하지 않을 경우 자동으로 추상"
            "메소드가 된다.\n\n\n"


            " 지금까지 확인한 상속 관련 변경자의 종류를 정리하면 다음과 같다.\n"
        </item>
    </string-array>

    <string-array name="explanation_8_6">
        <item>
            " 가시성 변경자는 클래스, 생성자, 프로퍼티, 메소드 등에 대한"
            "외부 접근을 제한할 때 사용한다. 코틀린의 가시성 변경자의 종류는"
            "다음과 같다.\n"
        </item>
        <item>
            "1. public\n\n"

            " 코틀린에서 어떠한 가시성 변경자도 명시하지 않는 경우 자동으로"
            "public 이 된다. 클래스 멤버나 최상위 변수, 최상위 함수를"
            "public 으로 지정하면 같은 모듈뿐 아니라 다른 모듈에서도"
            "접근할 수 있다. 만약 다른 사람들이 이용할 수 있도록 라이브러리를"
            "개발한다면 그 라이브러리 내의 클래스나 변수 등에 접근할 수 있도록"
            "가시성을 public 으로 지정해야 한다.\n\n\n\n"



            "2. internal\n\n"

            " internal 변경자는 같은 모듈 내에서만 접근이 가능하도록"
            "허용할 때 사용한다. 여기서 모듈이란 함께 컴파일되는 코틀린 파일들을"
            "의미한다. 모듈은 프로젝트보다 작은 개념으로 패키지와 클래스를 포함하는"
            "개념이다. 예를 들어 Intellij IDEA, Maven, Gradle 등의"
            "프로젝트가 모듈이 될 수 있다.\n\n\n\n"



            "3. protected\n\n"

            " protected 변경자는 최상위 선언에는 사용할 수 없고,"
            "클래스 멤버에만 사용할 수 있다. 클래스 멤버에 protected"
            "변경자를 사용하면 자기 자신과 그 클래스를 상속한 하위 클래스에서만"
            "접근이 가능하다. 같은 패키지 내에 있어도 클래스 자기 자신이거나"
            "그 클래스를 상속한 것이 아니라면 접근이 불가능하다.\n\n\n\n"



            "4. private\n\n"

            " 클래스 멤버에 private 변경자를 사용하면 같은 클래스에서만"
            "접근이 가능하다. 같은 클래스가 아니라면 하위 클래스를 포함한"
            "외부에서는 접근이 불가능하다. private 변경자를 최상위 선언에"
            "대해 사용하면 같은 파일에서만 접근이 가능하다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_8_7">
        <item>
            " 자바와 마찬가지로 코틀린에서도 클래스 내부에 다른 클래스를 선언할"
            "수 있다. 코틀린 중첩 클래스는 클래스 내부에 선언된 다른 클래스를"
            "의미한다. 자바와 다른 점은 코틀린 중첩 클래스는 바깥쪽 클래스에 대해"
            "접근할 수 없다는 점이다. 다음 예제를 보자.\n"
        </item>
        <item>
            " 위의 예제의 NestedClass 에서 바깥쪽 클래스인 OuterClass"
            "의 멤버에 대해 접근하려고 시도하고 있지만 오류가 발생하였다."
            "자바에서 다른 클래스 내에 선언한 중첩 클래스는 자동적으로"
            "내부 클래스가 되는 것과 다르게 코틀린의 중첩 클래스는 기본적으로"
            "자바의 static 중첩 클래스와 같다. 코틀린의 중첩 클래스는"
            "바깥쪽 클래스에 대해 접근이 불가능하다. 접근이 가능하게 하려면"
            "중첩 클래스를 내부 클래스로 변경해야 한다. 코틀린의 내부 클래스는"
            "자바의 Non-static 클래스와 같다. 코틀린의 중첩 클래스를"
            "내부 클래스로 변경해서 바깥쪽 클래스에 대해 접근이 가능하게 하려면"
            "inner 변경자를 사용하면 된다.\n"
        </item>
        <item>
            " 위의 예제처럼 중첩 클래스를 내부 클래스로 변경하면 바깥쪽 클래스에"
            "대해 접근이 가능하다. 바깥쪽 클래스 OutterClass 의 참조에"
            "접근하려면 this@OuterClass 로 사용하면 된다.\n\n\n"


            " 지금까지 알아본 중첩 클래스와 내부 클래스의 내용을 정리하면 다음과"
            "같다.\n"
        </item>
    </string-array>

    <string-array name="explanation_8_8">
        <item>
            " 코틀린의 sealed 클래스는 상위 클래스를 상속하는 하위 클래스의"
            "계층을 제한할 때 사용한다. 상위 클래스에 sealed 변경자를 붙이면"
            "계층 확장을 제한할 수 있다. sealed 클래스를 사용하는 예제는"
            "다음과 같다.\n"
        </item>
        <item>
            "\n sealed 클래스를 상속한 하위 클래스는 그 sealed 클래스를"
            "정의한 파일 내에 있어야 한다. 위의 예제처럼 하위 클래스는"
            "sealed 클래스 내부에 정의하거나 바깥쪽에 정의할 수 있다."
            "sealed 클래스는 기본적으로 abstract 클래스이다. 따라서"
            "open 변경자를 사용하지 않아도 상속이 가능하며, sealed"
            "클래스는 인스턴스화가 불가능하다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_8_9">
        <item>
            " 코틀린의 생성자 종류는 2가지가 있다. 하나는 주 생성자이고, 다른"
            "하나는 부 생성자이다. 코틀린의 주 생성자는 클래스 본문 밖에 존재하며,"
            "클래스를 초기화할 때 주로 사용하는 간략한 생성자이다. 주 생성자는"
            "클래스 뒤에 오는 괄호로 둘러싸인 코드이다. 주 생성자는 생성자"
            "파라미터를 지정한다. 그리고 그 생성자 파라미터에 의해 클래스 프로퍼티가"
            "초기화된다. 이번 절에서는 주 생성자를 어떻게 사용하는지 알아본다."
            "다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 constructor 와 init 키워드를 사용하였다."
            "constructor 키워드는 주 생성자 또는 부 생성자를 생성할 때"
            "사용한다. init 키워드는 클래스의 객체가 새로 생성될 때 실행되는"
            "초기화 코드를 포함하는 초기화 블록을 사용할 때 사용한다. 주 생성자"
            "안에는 어떠한 코드도 들어갈 수 없으므로 코드가 필요하면 초기화 블록을"
            "사용하면 된다. 위의 예제에서 새로운 Person 객체를 생성하자마자"
            "초기화 블록이 실행되어 2번의 println 함수가 실행되었다. 별도의"
            "코드가 필요하지 않고 프로퍼티를 파라미터로 초기화만 하면 된다면"
            "다음과 같이 초기화 블록을 없애도 된다.\n"
        </item>
        <item>
            " 또한 주 생성자 앞에 어노테이션이나 가시성 변경자가 없다면"
            "constructor 키워드를 생략할 수 있다.\n"
        </item>
        <item>
            " 주 생성자의 파라미터로 프로퍼티를 초기화할 경우 주 생성자 파라미터"
            "앞에 val 또는 var 키워드를 붙여서 프로퍼티 정의 및 초기화를"
            "간략화할 수 있다.\n"
        </item>
        <item>
            " 함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 지정할"
            "수 있다. 자바에서의 생성자 오버로딩을, 코틀린에서는 디폴트 값을"
            "사용함으로써 대체할 수 있다.\n"
        </item>
        <item>
            " 하위 클래스에서 상위 클래스를 상속한다면 그 상위 클래스의 생성자를"
            "호출할 필요가 있다.\n"
        </item>
        <item>
            " 클래스를 생성할 때 생성자를 정의하지 않으면 디폴트 생성자가 만들어진다."
            "그리고 그 클래스를 하위 클래스가 상속할 때 상위 클래스의 생성자를"
            "호출해야 한다.\n"
        </item>
        <item>
            " 위의 예제처럼 하위 클래스가 상위 클래스를 상속할 때는 상위 클래스의"
            "생성자를 호출해야 하기 때문에 상위 클래스의 이름 뒤에 반드시 괄호를"
            "작성해야 한다. 이와 달리, 인터페이스는 생성자가 존재하지 않기 때문에"
            "괄호를 사용하지 않는다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_8_10">
        <item>
            " 코틀린에서는 주 생성자 파라미터에 디폴트 값을 지정함으로써 생성자"
            "오버로딩을 대체하여 생성자가 여러 개 존재하는 경우가 적다."
            "하지만 클래스를 여러 방법으로 초기화해야 할 때는 생성자가 여러 개"
            "필요할 수 있다. 이런 경우 코틀린 부 생성자를 사용하여 해결할 수"
            "있다. 코틀린 부 생성자는 클래스 본문 내에 존재하며 constructor"
            "키워드를 사용한다. 주 생성자와 달리 constructor 키워드를"
            "생략할 수 없다. 부 생성자는 1개 또는 그 이상 존재할 수 있다."
            "부 생성자를 사용하는 방법은 다음과 같다.\n"
        </item>
        <item>
            "\n\n\n\n"
            " 위의 예제에서 2개의 부 생성자를 정의하였다. 인자로 넘기는"
            "파라미터의 종류에 따라 실행되는 부 생성자가 달라진다. 자바와"
            "마찬가지로 생성자가 다른 생성자를 호출하는 것이 가능하다."
            "this() 을 사용함으로써 다른 생성자를 호출할 수 있다.\n"
        </item>
        <item>
            "\n\n\n\n"
            " 부 생성자에서 super() 을 사용해서 상위 클래스의 생성자를"
            "호출하는 것이 가능하다.\n"
        </item>
        <item>
            "\n\n\n\n 부 생성자에서 주 생성자를 호출할 수도 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_8_11">
        <item>
            " 어떤 클래스가 데이터를 저장하는 역할을 수행한다면 오버라이드해야"
            "할 메소드가 있다. 바로 toString, equals, hashCode"
            "메소드이다. data 클래스를 사용하면 위의 메소드들을 자동으로"
            "생성해준다. 추가로 copy 메소드도 자동으로 생성해준다."
            "data 변경자를 클래스 앞에 붙이면 data 클래스를 사용할 수 있다.\n"
        </item>
        <item>
            "\n\n data 클래스는 다음 조건을 만족해야 한다.\n\n\n"


            "(1):\n"
            " 주 생성자에 최소 하나의 파라미터가 존재한다.\n\n"

            "(2):\n"
            " 모든 주 생성자 파라미터는 val 또는 var 로 선언되어야 한다.\n\n"

            "(3):\n"
            " data 클래스는 abstract, open, sealed, inner"
            "클래스가 될 수 없다.\n\n\n"


            "data 클래스가 자동으로 생성해주는 메소드를 하나씩 알아보자.\n\n\n\n"



            "1. toString 메소드\n\n"

            " data 클래스의 toString 메소드는 다음과 같이 클래스"
            "이름과 모든 파라미터를 문자열로 반환한다.\n"
        </item>
        <item>
            "\n\n"
            " 참고로 기본적으로 제공되는 toString 메소드는 다음과 같은"
            "문자열을 반환한다.\n"
        </item>
        <item>
            "\n 위와 같이 기본적으로 제공되는 toString 메소드가 반횐하는 문자열은"
            "그다지 도움되지 않으므로 오버라이드해야 한다.\n\n\n\n"



            "2. equals 메소드\n\n"

            " equals 메소드는 두 객체의 동등성을 확인하는 메소드이다."
            "코틀린의 equals 메소드는 == 연산자로 호출이 가능하다."
            "기본적으로 제공되는 equals 메소드와 data 클래스의 equals"
            "메소드를 비교하면 다음과 같다."
        </item>
        <item>
            "\n\n"
            " 클래스 내의 데이터가 같더라도 일반 클래스의 equals 메소드는"
            "false 를, data 클래스의 equals 메소드는 true 을"
            "반환하였다. 객체의 동등성을 비교하려면 data 클래스를 사용하거나,"
            "아니면 다음과 같이 equals 메소드를 오버라이드하면 된다."
        </item>
        <item>
            "\n\n"
            " 위의 예제에서 Any 는 코틀린의 최상위 타입을 의미한다. 그리고"
            "Any 뒤에 붙은 ? 은 그 타입이 null 이 될 수 있음을 의미한다."
            "Any 타입은 12.3 절에서, ? 에 대해선 11.1 절에서 설명한다.\n\n\n\n"



            "3. hashCode 메소드\n\n"

            " 일반적으로 equals 메소드를 오버라이드한 경우 hashCode 메소드도"
            "오버라이드해야 한다. equals 메소드만 오버라이드하고"
            "hashCode 메소드를 오버라이드하지 않았을 경우 생기는 문제점을"
            "알아보자.\n"
        </item>
        <item>
            "\n\n"
            " 위의 예제에서 HashSet 에는 어떤 Person 객체가 존재하고"
            "그 Person 객체와 모든 프로퍼티의 값이 동일한 객체를 찾고 있다."
            "true 를 반환해야 할 것 같지만 false 가 반환되었다. 이는"
            "hashCode 메소드를 오버라이드하지 않았기 때문이다."
            "JVM 언어에서 equals 메소드가 true 을 반환하는 두 객체는"
            "hashCode 메소드가 동일한 값을 반환해야 한다.\n"
        </item>
        <item>
            "\n\n\n\n4. Copy 메소드\n\n"

            " data 클래스는 Copy 메소드를 자동으로 생성해준다."
            "자동으로 생성된 Copy 메소드를 직접 구현하면 다음과 같다.\n"
        </item>
    </string-array>

    <string-array name="explanation_8_12">
        <item>
            " 코틀린의 by 키워드는 클래스 위임을 할 때 사용한다. 여기서"
            "위임(Delegation)이란 어떤 클래스의 기능을 다른 클래스로"
            "넘긴다는 의미이다. 클래스 위임을 사용하면 메소드나 접근자의"
            "구현을 다른 클래스가 대신 처리하도록 할 수 있다.\n\n\n\n"



            "1. 위임을 사용하는 이유\n\n"

            " 위임을 사용하는 이유는 상속 관련해서 문제가 발생할 수 있기"
            "때문이다. 객체지향 프로그래밍을 할 때 상위 클래스를 하위 클래스가"
            "상속해서 상위 클래스의 메소드를 오버라이드하는 경우가 많다. 이런 경우"
            "상위 클래스의 메소드 구현이 변경되면 하위 클래스의 오버라이드한"
            "메소드에 영향을 줄 수 있다.\n"
            " 코틀린의 클래스는 기본적으로 final 이기 때문에 open 변경자로"
            "상속을 허용한 클래스만 확장이 가능하다. open 변경자로 명시한"
            "클래스만 하위 클래스가 상속이 가능하므로 open 변경자를 보고"
            "상위 클래스의 메소드를 수정할 때 하위 클래스에 영향을 줄 수 있다는"
            "것을 인지하고 주의를 기울일 수 있다.\n\n\n\n"



            "2. 데코레이터 패턴\n\n"

            " 상속을 허용하지 않는 클래스에 새로운 기능을 추가할 때 데코레이터"
            "패턴을 사용할 수 있다. 데코레이터 패턴이란 상속을 허용하지 않는"
            "클래스가 구현하는 인터페이스를 구현하는 클래스를 생성하고 상속을"
            "허용하지 않는 클래스의 인스턴스를 새로운 클래스 내부에 생성하는"
            "것이다. 데코레이터 패턴을 사용한 예제는 다음과 같다.\n"
        </item>
        <item>
            " 위의 예제에서 상속을 허용하지 않는 클래스 B 가 구현하는"
            "인터페이스 A 를 새로운 클래스 C 가 구현하고, 클래스 B 의 인스턴스를"
            "클래스 C 내부에 생성하였다. 그리고 인터페이스 A 의 프로퍼티와 메소드를"
            "클래스 B 의 프로퍼티와 메소드를 사용하도록 하고, 새로운 메소드를"
            "작성하였다. 위의 예제처럼 상속이 불가능한 클래스의 프로퍼티나 메소드의"
            "수가 적으면 괜찮지만 이보다 많으면 작성해야 할 코드가 많아진다."
            "다행히도 코틀린에서는 이러한 위임을 by 키워드를 통해 지원해준다.\n\n\n\n"



            "3. by 키워드를 상속한 클래스 위임\n\n"

            " by 키워드를 사용하면 위의 예제의 위임을 쉽게 작성할 수 있다."
            "위의 예제를 by 키워드를 사용해서 재작성하면 다음과 같다.\n"
        </item>
        <item>
            " 구현할 필요가 있었던 인터페이스 A의 프로퍼티와 메소드를 작성하지"
            "않아도 by 키워드를 통해 클래스 B의 인스턴스에 위임시켰다. 이처럼"
            "by 키워드를 사용하면 클래스 위임을 쉽게 사용할 수 있다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_8_13">
        <item>
            " 코틀린의 object 키워드는 클래스를 정의하면서 인스턴스를"
            "생성한다. object 키워드를 사용하는 방법은 여러 가지가 있다.\n\n\n\n"



            "1. 싱글톤(Singleton) 객체 생성\n\n"

            " 싱글톤이란 단 하나의 객체만 존재하는 것을 의미한다. 코틀린의"
            "object 키워드를 사용하면 싱글톤 객체를 쉽게 생성할 수 있다."
            "object 키워드를 사용한 예제는 다음과 같다.\n"
        </item>
        <item>
            "\n 위의 예제와 같이 object 키워드 뒤에 객체 이름을 지정하면"
            "싱글톤 객체를 생성할 수 있다. 클래스와 마찬가지로 프로퍼티, 메소드,"
            "초기화 블록이 존재할 수 있지만, 생성자는 존재할 수 없다. 클래스를"
            "선언하자마자 생성자 호출없이 하나의 객체가 자동으로 생성되기 때문이다."
            "또한 생성자를 호출하지 않으므로 프로퍼티의 값을 객체 선언 내부에서"
            "초기화해야 한다. 객체 선언 내부에서는 const val 키워드를"
            "사용해서 상수를 정의할 수 있다. 또한 객체 선언도 클래스나 인터페이스를"
            "상속할 수 있다.\n\n\n\n"



            "2. 동반 객체\n\n"

            " 코틀린은 자바와 달리 static 키워드를 지원하지 않는다. 대신"
            "최상위 함수를 사용하거나 object 키워드를 이용한 객체 선언 등으로"
            "대체할 수 있다. 하지만 최상위 함수는 클래스의 private 멤버에"
            "접근할 수 없다. 이처럼 객체를 생성하지 않고도 호출이 가능해야"
            "하지만 클래스 내부 정보에 접근이 가능해야 한다면 동반 객체를"
            "사용해야 한다. 동반 객체를 사용하면 자바의 정적 멤버 호출 구문을"
            "사용할 수 있다. 동반 객체는 companion object 라는"
            "키워드를 사용하며, 객체의 이름을 지정할 필요가 없다. 또한 동반"
            "객체는 클래스 내에 하나만 존재할 수 있다.\n"
        </item>
        <item>
            "\n 위의 예제와 같이 동반 객체 내에 선언한 변수 count 는 자바의"
            "클래스 내의 정적 멤버로 선언한 것과 같다. 따라서 객체를 생성하지"
            "않고도 사용할 수 있다. 또한 생성된 객체의 수라는 클래스 내부 정보에"
            "대한 접근이 가능해졌다.\n"
            " 동반 객체는 자신을 포함하고 있는 클래스의 private 멤버에"
            "접근할 수 있다. 특히 private 생성자를 호출할 수 있기 때문에"
            "팩토리 메소드를 구현하기 좋다. 예를 들어 다음과 같이 2개의 부"
            "생성자가 있는 클래스가 있다고 가정해보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 문자열을 인자로 넘기면 이메일을 아이디로 갖는 계정을,"
            "정수를 인자로 넘기면 정수 아이디를 갖는 계정을 만든다. 위의 예제를"
            "동반 객체를 이용한 팩토리 메소드로 구현할 수 있다. 동반 객체를"
            "이용해 팩토리 패턴을 구현한 예제는 다음과 같다.\n"
        </item>
        <item>
            "\n 위의 예제처럼 동반 객체의 메소드를 호출하여 객체를 생성할 수 있다."
            "단, 동반 객체의 멤버는 하위 클래스에서 오버라이드할 수 없으므로"
            "클래스의 상속을 허용하는 경우에는 생성자를 여러 개 갖는 것이 낫다."
            " 동반 객체도 마찬가지로 확장 함수를 정의할 수 있다. 동반 객체에 대한"
            "확장 함수를 정의한 예제는 다음과 같다.\n"
        </item>
        <item>
            "\n동반 객체에 이름을 지정하지 않는 경우 자동으로 Companion 이"
            "된다.\n"
        </item>
        <item>
            "\n\n\n\n3. 무명 객체\n\n"

            " object 키워드를 이용해서 무명 객체를 정의할 수 있다. 무명"
            "객체는 자바의 무명 내부 클래스를 대신한다. 예를 들어 배열을"
            "정렬할 때 사용하는 Comparator 을 구현할 때 사용할 수 있다.\n"
        </item>
        <item>
            "\n 위의 예제와 같이 무명 객체를 정의할 때는 객체 이름을 붙이지"
            "않는다. 무명 객체는 싱글톤과 달리 사용될 때마다 새로운 인스턴스가"
            "생성되며, 여러 인터페이스를 구현하거나 클래스를 상속하면서 인터페이스를"
            "구현할 수 있다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_8_14">
        <item>
            " enum 클래스는 enum class 키워드를 사용해서 정의할 수 있다."
            "자바에서는 enum 으로 사용하는 것과 달리 코틀린에서는 enum"
            "class 으로 사용한다. enum 클래스를 사용한 예제는 다음과 같다.\n"
        </item>
        <item>
            "\n\n"
            " 자바와 마찬가지로 코틀린의 enum 클래스는 프로퍼티와 메소드를"
            "정의할 수 있다. enum 클래스도 일반적인 클래스처럼 생성자와 프로퍼티를"
            "지정한다. 각 enum 상수를 정의할 때 그 상수에 해당하는"
            "프로퍼티 값을 지정해야 한다. 또한 enum 클래스 안에 메소드를"
            "정의하는 경우 반드시 enum 상수와 메소드 사이에 세미콜론(;)을"
            "넣어야 한다.\n"
        </item>
    </string-array>

    <string-array name="explanation_9_1">
        <item>
            " 코틀린의 컬렉션은 자바와 달리 읽기 전용 컬렉션과 변경 가능한"
            "컬렉션으로 구분된다. 이는 코틀린에서 컬렉션 내의 데이터에 접근하는"
            "인터페이스와 컬렉션 내의 데이터를 변경하는 인터페이스가 분리되어"
            "있기 때문이다. 전자는 Kotlin.collections.Collection,"
            "후자는 Kotlin.collections.MutableCollection 에"
            "해당한다. MutableCollection 은 Collection 을"
            "확장하면서 내부 데이터 변경 메소드를 제공한다. 컬렉션을 생성하는"
            "함수를 정리하면 다음과 같다.\n"
        </item>
    </string-array>

    <string-array name="explanation_9_2">
        <item>
            " List 는 데이터를 순서대로 저장하는 Collection 이다."
            "List 를 생성하는 방법은 다음과 같다.\n"
        </item>
        <item>
            " 위의 예제에서 인자를 넘기지 않으면 내부에 데이터가 없는 List"
            "가 생성되고, 인자를 넘기면 넘긴 인자를 데이터로 갖는 List 가"
            "생성된다. 또한 listOf 로 생성한 List 는 읽기 전용 컬렉션으로"
            "데이터를 추가, 삭제 및 수정을 할 수 없지만, mutableListOf,"
            "arrayListOf 로 생성한 List 는 변경 가능한 컬렉션으로"
            "데이터를 추가, 삭제 및 수정을 할 수 있다.\n\n\n\n"



            "1. 데이터 추가: add 와 addAll 메소드\n\n"

            " 변경 가능한 List 에 데이터를 추가하려면 add 또는 addAll"
            "메소드를 사용하면 된다. add 메소드는 하나의 데이터를, addAll"
            "메소드는 여러 개의 데이터를 추가할 수 있다. addAll 메소드의"
            "인자로 다른 컬렉션을 넘기면 그 컬렉션 내의 데이터 모두를 추가할"
            "수 있다.\n"
        </item>
        <item>
            "\n\n\n\n"
            "2. 데이터 삭제: remove 와 removeAt 메소드\n\n"

            " remove 메소드의 인자로 특정 값을 넘기면 그 값과 같은"
            "첫 번째로 찾은 원소를 삭제한다. removeAt 메소드는 인자로"
            "인덱스를 받는다.\n"
        </item>
        <item>
            "\n\n\n\n"
            "3. 데이터 수정: set 메소드\n\n"

            " set 메소드를 사용하면 특정 인덱스의 값을 다른 값으로 변경할"
            "수 있다. set 메소드는 [ ] 를 사용해서 호출할 수 있다.\n"
        </item>
        <item>
            "\n\n\n\n"
            " 위에서 살펴본 메소드 이외의 List 와 관련된 메소드는 다음"
            "주소에서 확인할 수 있다.\n\n"
        </item>
        <item>
            "https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/#kotlin.collections.MutableList\n\n"
        </item>
    </string-array>

    <string-array name="explanation_9_3">
        <item>
            " Set 은 데이터의 중복을 허용하지 않으며 데이터가 정렬되어 있지"
            "않은 Collection 이다. Set 을 생성하는 방법은 다음과 같다.\n"
        </item>
        <item>
            " 위의 예제에서 인자를 넘기지 않으면 내부에 데이터가 없는 Set 이"
            "생성되고, 인자를 넘기면 넘긴 인자를 데이터로 갖는 Set 이"
            "생성된다. 또한 setOf 로 생성한 Set 은 읽기 전용 Set 으로"
            "데이터를 추가하거나 삭제를 할 수 없지만, mutableSetOf,"
            "hashSetOf, linkedSetOf, sortedSetOf 으로 생성한 Set 은"
            "변경 가능한 Set 으로 데이터를 추가하거나 삭제를 할 수 있다.\n\n\n\n"



            "1. 데이터 추가: add 와 allAll 메소드\n\n"

            " 변경 가능한 Set 에 데이터를 추가하려면 add 또는 addAll"
            "메소드를 사용하면 된다. add 메소드는 하나의 데이터를, addAll"
            "메소드는 여러 개의 데이터를 추가할 수 있다. addAll() 메소드의"
            "인자로 다른 컬렉션을 넘기면 그 컬렉션 내의 데이터 중 이미 Set 에"
            "존재하는 데이터를 제외한 모든 데이터를 추가할 수 있다.\n"
        </item>
        <item>
            "\n\n\n\n"
            "2. 데이터 삭제: remove 메소드\n\n"

            " remove 메소드의 인자로 특정 값을 넘기면 그 값이 Set"
            "의 내부에 존재할 경우 그 값을 삭제한다.\n"
        </item>
        <item>
            "\n\n\n\n"
            " 위에서 살펴본 메소드 이외의 Set 과 관련된 메소드는 다음"
            "주소에서 확인할 수 있다.\n\n"
        </item>
        <item>
            "https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/"
            "\n\n"
        </item>
    </string-array>

    <string-array name="explanation_9_4">
        <item>
            " Map 은 키와 값의 쌍을 이용해서 데이터를 저장하는 Collection"
            "이다. 키의 값은 중복될 수 없지만, 값은 중복될 수 있다."
            "Map 을 생성하는 방법은 다음과 같다.\n"
        </item>
        <item>
            " 위의 예제에서 인자를 넘기지 않으면 내부에 데이터가 없는 Map 이"
            "생성되고, 인자를 넘기면 넘긴 인자를 데이터로 갖는 Map 이"
            "생성된다. 넘기는 인자의 타입은 Pair 이다. Pair 객체는"
            "두 개의 값을 저장하는 하나의 객체이다. Pair 객체를 만들려면"
            "Pair(A, B) 처럼 두 개의 인자를 넘기거나, A to B 처럼"
            "to 함수를 사용하면 된다. to 함수는 중위함수로 Pair 의"
            "인스턴스를 반환한다. 또한 mapOf 로 생성한 Map 은 읽기 전용"
            "Map 으로 데이터를 추가, 삭제 및 수정을 할 수 없지만, mutableMapOf,"
            "hashMapOf, linkedMapOf, sortedMapOf 으로 생성한 Map 은"
            "변경 가능한 Map 으로 데이터를 추가, 삭제 및 수정을 할 수 있다.\n\n\n\n"



            "1. 데이터 추가: put 메소드\n\n"

            " 변경 가능한 Map 에 데이터를 추가하려면 put 메소드를"
            "사용하면 된다. 첫 번째 인자에 key 을, 두 번째 인자에 value"
            "을 넘기면 된다. 인자로 넘긴 키가 이미 Map 에 존재할 경우"
            "인자로 넘긴 value 로 값을 덮어쓴다. 만약 덮어쓰기를 허용하고"
            "싶지 않다면 putIfAbsent 메소드를 사용하면 된다. 또한"
            "put 메소드는 [ ] 와 = 을 이용해서 대체될 수 있다.\n"
        </item>
        <item>
            "\n\n\n\n"
            "2. 데이터 삭제: remove 메소드\n\n"

            " remove 메소드의 인자로 키 값을 넘기면 그 키가 Map"
            "의 내부에 존재할 경우 해당 키와 그 키에 해당하는 값을 삭제한다."
            "인자로 넘긴 키 값이 Map 내부에 존재하지 않으면 아무 것도"
            "삭제하지 않는다. 또한 키뿐만 아니라 값도 넘기면 키와 값 모두"
            "일치해야만 삭제한다.\n"
        </item>
        <item>
            "\n\n\n\n"
            " 위에서 살펴본 메소드 이외의 Map 과 관련된 메소드는 다음"
            "주소에서 확인할 수 있다.\n\n"
        </item>
        <item>
            "https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-map/"
            "\n\n"
        </item>
    </string-array>

    <string-array name="explanation_10_1">
        <item>
            " 람다는 쉽게 말해서 함수에 인자로 넘기는 익명 함수 또는 반환값으로 얻을"
            "수 있는 익명 함수이다. 코틀린에서는 특히 컬렉션에 대해서 람다를"
            "자주 사용한다. 람다 식의 문법은 다음과 같다.\n\n"

            "{ x: Int, y: Int -> x + y }\n\n"

            " 위와 같이 람다 식은 중괄호로 둘러싸여 있다. 람다 식은 크게 두"
            "부분으로 구분된다. 하나는 화살표 이전 부분으로 람다 식의 인자"
            "목록을 나타내며 인자 목록을 여러 개 선언할 때는 콤마(,)로"
            "구분한다. 다른 하나는 화살표 이후 부분으로 람다 식의 본문이다.\n"
            " 람다 식은 변수에 저장할 수 있다. 그리고 변수에 저장된 람다 식을"
            "일반 함수처럼 사용할 수 있다.\n"
        </item>
        <item>
            "\n 위의 예제에서 변수 sum 에는 두 정수의 합을 구하는 람다 식이"
            "저장되어 있고 일반 함수를 사용하듯이 호출되었다. (Int, Int) ->"
            "Int 부분은 람다 식의 타입을 나타낸다. 일반 변수와 마찬가지로"
            "코틀린 컴파일러는 람다 식의 타입을 추론할 수 있다. 람다 식 내부의"
            "파라미터에 이미 타입이 명시되어 있기 때문에 변수의 타입을 생략할"
            "수 있다. 또는 변수의 타입을 생략하는 대신 람다 식 파라미터의 타입을"
            "생략할 수 있다.\n"
        </item>
        <item>
            "\n 람다 식의 본문이 여러 줄로 이루어진 경우 마지막 줄이 람다 식의"
            "결과 값이 된다.\n"
        </item>
        <item>
            "\n 어떤 함수를 호출할 때 그 함수의 마지막 인자가 람다 식인 경우"
            "그 람다 식을 괄호 밖으로 뺄 수 있다. 또한 어떤 함수의 인자가"
            "람다 식 하나 뿐일 경우 괄호 자체를 없애고 람다 식만 함수 이름"
            "뒤에 작성할 수 있다.\n"
        </item>
        <item>
            "\n 위의 예제에서 파라미터 타입을 생략해도 컴파일러가 자동으로 추론해준다."
            "또한 람다 식의 파라미터가 오직 하나 뿐인 경우 파라미터 이름으로"
            "디폴트 이름인 it 을 사용할 수 있다. it 은 iterator 을"
            "의미한다. 타입까지 추론할 수 있는 경우 람다 식 본문만 존재할 수 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_10_2">
        <item>
            " 멤버 참조(Member Reference)란 프로퍼티나 메소드를"
            "단 하나만 호출하는 함수 값을 반환하는 식을 말한다. 멤버 참조를"
            "사용하려면 클래스 이름과 프로퍼티 또는 메소드 사이에 :: 을"
            "사용하면 된다.\n"
        </item>
        <item>
            "\n 위의 예제에서 Person::age 부분이 멤버 참조를 사용한"
            "부분이다. 멤버 참조는 그 멤버를 호출하는 람다와 같은 타입으로"
            "Person::age 는 { person: Person -> person.age }"
            "와 동일하다.\n"
            " :: 앞에 클래스 이름을 적지 않으면 최상위 함수나 프로퍼티도"
            "참조할 수 있다.\n"
        </item>
        <item>
            "\n 생성자 참조(Constructor Reference)를 사용하면"
            "클래스 생성을 연기 또는 저장할 수 있다.\n"
        </item>
        <item>
            "\n확장 함수도 :: 을 사용하면 참조가 가능하다.\n"
        </item>
    </string-array>

    <string-array name="explanation_10_3">
        <item>
            " 코틀린에서 컬렉션 처리 함수에 람다를 자주 사용한다. 이번 절에서는"
            "코틀린 람다를 사용하는 컬렉션과 관련된 주요 함수를 알아본다.\n\n\n\n"



            "1. filter 함수\n\n"

            " filter 함수는 컬렉션 내의 각 원소를 람다 식으로 넘겼을 때"
            "true 을 반환하는 원소만 모아서 반환하는 함수이다. 예를 들어,"
            "컬렉션 원소 중 짝수만 반환하는 방법은 다음과 같다.\n"
        </item>
        <item>
            "\n\n\n\n2. map 함수\n\n"

            " map 함수는 컬렉션 내의 각 원소를 람다 식으로 넘겨서 얻은"
            "결과를 모아서 반환하는 함수이다.\n"
        </item>
        <item>
            "\n\n\n\n3. filterKeys 와 mapKeys 함수\n\n"

            " filterKeys, mapKeys 함수를 사용하면 컬렉션 Map 의"
            "키를 걸러내거나 변환할 수 있다. filterKeys 함수를 사용할 경우"
            "람다 내의 it 은 키에 해당하고, mapKeys 함수를 사용할 경우"
            "람다 내의 it 은 Map.Entry 객체에 해당한다.\n"
        </item>
        <item>
            "\n\n\n\n4. filterValues 와 mapValues 함수\n\n"

            " filterValues, mapValues 함수를 사용하면 컬렉션 Map 의"
            "값을 걸러내거나 변환할 수 있다.\n"
        </item>
        <item>
            "\n\n\n\n5. all 와 any 함수\n\n"

            " all 함수는 컬렉션 내의 모든 원소를 람다 식으로 넘겼을 때"
            "모두 true 을 반환하면 true 을 반환하고, 하나라도 false"
            "일 경우 false 을 반환한다. any 함수는 컬렉션 내의 모든 원소를"
            "람다 식으로 넘겼을 때 하나라도 true 이면 true 을 반환하고,"
            "그렇지 않을 경우 false 을 반환한다.\n"
        </item>
        <item>
            "\n\n\n\n6. count 함수\n\n"

            " count 함수는 컬렉션 내의 원소를 람다 식으로 넘겼을 때"
            "true 을 반환한 개수를 구한다.\n"
        </item>
        <item>
            "\n\n\n\n7. find 함수\n\n"

            " find 함수는 컬렉션 내의 모든 원소 중 람다 식으로 넘겼을 때"
            "true 을 반환하는 첫 번째 원소를 반환한다.\n"
        </item>
        <item>
            "\n\n\n\n8. groupBy 함수\n\n"

            " groupBy 함수는 하나의 List 을 여러 개의 그룹으로 이루어진"
            "Map 으로 변경하는 함수이다. 람다 식으로 컬렉션 내의 원소를 구분할"
            "속성을 넘기면 그 속성이 Map 의 키가 되고, 그 키에 따른 그룹이"
            "값이 된다.\n"
        </item>
        <item>
            "\n\n\n\n9. flatMap 와 flatten 함수\n\n"

            " flatMap 와 flatten 함수는 중첩된 컬렉션을 하나의 List 으로"
            "변환하는 함수이다. flatMap 함수는 컬렉션 내의 모든 원소를"
            "람다 식으로 넘겨 얻은 여러 개의 List 을 하나의 List 로"
            "변환한다.\n"
        </item>
        <item>
            "\n flatMap 과 달리 람다 식을 통해 변환해야 할 내용이 없는"
            "List 내의 List 는 flatten 함수를 통해 하나의 List 로"
            "변환할 수 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_10_4">
        <item>
            " 10.3 절에서 살펴본 filter 나 map 과 같은 컬렉션"
            "함수는 연쇄시키는 것이 가능하다. filter 와 map 함수는"
            "연쇄시킨 예제는 다음과 같다.\n"
        </item>
        <item>
            "\n 위의 예제에서 filter 함수와 map 함수 각각 List 을 반환한다."
            "즉, 두 함수의 연쇄로 인해 2개의 List 가 생성된다는 뜻이다."
            "원본 컬렉션 내의 원소의 개수가 적으면 컬렉션 함수를 여러 개"
            "연쇄시키는 것은 큰 문제가 되지 않지만, 원소의 개수가 많을 경우"
            "여러 개의 컬렉션이 생성될 때 시간이 걸리면서 효율성이 떨어지게 된다.\n"
            " 이런 경우 시퀀스(Sequence)를 사용하면 효율성을 높일 수 있다."
            "시퀀스를 사용하는 방법은 다음과 같다.\n"
        </item>
        <item>
            "\n 위의 예제처럼 시퀀스를 사용하려면 asSequence 함수를"
            "호출하면 된다. asSequence 함수는 컬렉션을 시퀀스로 변환하는"
            "함수이다. 시퀀스를 사용하면 최종 결과를 얻을 때까지 지연 계산되어"
            "중간 결과를 저장하지 않아서 효율성을 높일 수 있다.\n"
            " 시퀀스의 연산은 두 가지로 구분된다. 하나는 중간 연산이고, 나머지"
            "하나는 최종 연산이다. 중간 연산은 다른 시퀀스를 반환하고, 최종 연산은"
            "결과를 반환한다. 위의 예제에서 filter, map 함수 호출 부분이"
            "중간 연산 부분이다. 중간 연산으로 얻어진 시퀀스는 이전 시퀀스의"
            "원소를 변환하는 방법을 알고 있는 시퀀스이다. 위의 예제에서 toList"
            "함수 호출 부분이 최종 연산 부분이다. 최종 연산은 시퀀스 연산으로"
            "얻을 수 있는 컬렉션, 원소, 숫자, 객체 중 하나에 해당한다.\n"
            " 기존의 컬렉션 함수를 연쇄하는 것과 달리 시퀀스를 사용하면 지연"
            "계산되어 최종 연산을 수행하기 전에는 결과를 얻을 수 없다. 다음"
            "예제를 보자.\n"
        </item>
        <item>
            "\n 위의 코드는 최종 연산 부분이 존재하지 않는다. 따라서 결과를 얻을"
            "수 없다. 이렇듯 시퀀스를 사용하면 결과를 얻기 전에는 지연 계산된다.\n"
            " 또한 시퀀스를 사용하는 것과 시퀀스를 사용하지 않고 컬렉션 함수를"
            "연쇄시키는 것은 서로 연산 순서가 다르다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 시퀀스를 사용하지 않고 컬렉션 함수를 연쇄시킬 경우"
            "원본 컬렉션 내의 모든 원소에 대해 하나의 함수를 호출한 뒤에 다른"
            "함수를 호출한다. 이와 달리 시퀀스를 사용할 경우 원본 컬렉션 내의"
            "원소를 하나씩 처리한다.\n"
            " 지금까지 알아본 시퀀스를 사용하는 방법은 모두 원본 컬렉션을"
            "시퀀스로 변환해서 사용한 것이다. 직접 시퀀스를 만들려면"
            "generateSequence 함수를 사용하면 된다. 직접 시퀀스를 생성해서"
            "사용하는 방법은 다음과 같다.\n"
        </item>
    </string-array>

    <string-array name="explanation_10_5">
        <item>
            " 함수형 인터페이스란 추상 메소드 하나만 존재하는 인터페이스를 말한다."
            "코틀린에서는 함수형 인터페이스를 인자로 받는 함수를 호출할 때"
            "람다를 넘길 수 있다. 다음 예제를 보자.\n"
        </item>
        <item>
            " 위의 예제에서 onClick 이라는 추상 메소드만 포함하는 인터페이스를"
            "구현한 무명 객체를 인자로 넘겼다. 이런 예제처럼 함수형 인터페이스를"
            "인자로 받는 함수의 경우 람다를 인자로 넘길 수 있다. 다음은 위의 예제를"
            "람다 식을 사용한 예제로 바꾼 것이다.\n"
        </item>
        <item>
            "\n\n 위의 예제처럼 람다 식을 인자로 넘긴 경우 코드가 더 간결해진다."
            "또한 인자로 무명 객체를 넘기는 것과 람다를 넘기는 것에는 차이가"
            "있다. 무명 객체를 넘기는 경우 메소드가 호출될 때마다 새로운"
            "객체가 호출된다. 이와 달리 람다를 넘기는 경우 정의가 들어있는"
            "함수의 변수에 접근하지 않는 람다에 대응하는 무명 객체를 반복해서"
            "사용한다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_10_6">
        <item>
            " Scope 함수를 사용하면 람다 식 내의 일시적인 범위를 생성하고,"
            "이 범위 내에서 객체의 이름을 사용하지 않고 it 또는 this 로"
            "객체에 접근할 수 있다. Scope 함수에 해당하는 것으로는"
            "with, apply, let, run, also 가 있다.\n\n\n\n"



            "1. with 함수\n\n"

            " with 함수는 null 이 될 수 없는 수신 객체에 대해서 사용하며,"
            "어떠한 결과 값도 반환될 필요가 없을 때 주로 사용한다. with"
            "함수의 첫 번째 인자에 객체를 넘기면 그 객체가 두 번째 인자로"
            "넘긴 람다의 수신 객체가 되어 람다 내에서 수신 객체를 명시하지"
            "않고도 수신 객체의 프로퍼티나 메소드를 호출할 수 있다.\n"
        </item>
        <item>
            "\n 만약 수신 객체의 프로퍼티나 메소드의 이름이 다른 변수나 함수의"
            "이름과 겹친다면 this 을 사용해서 명시적으로 나타낼 수 있다.\n"
        </item>
        <item>
            "\n\n\n\n2. apply 함수\n\n"

            " apply 함수는 with 함수와 달리 수신 객체 자기 자신을 반환해야"
            "할 필요가 있을 때 사용한다. apply 함수는 주로 객체를 생성하자마자"
            "초기화할 때 사용한다.\n"
        </item>
        <item>
            "\n 위의 예제에서 StringBuilder 객체를 생성하자마자 apply 함수를"
            "이용해 초기화하였다. 그리고 초기화한 StringBuilder 객체를"
            "toString 메소드를 사용해서 문자열로 변환하였다.\n"
            " 위의 예제를 buildString 함수를 사용하면 더 간결하게"
            "문자열을 생성할 수 있다.\n"
        </item>
        <item>
            "\n\n\n\n3. let 함수\n\n"

            " let 함수는 호출한 함수의 결과에 대해 여러 개의 함수를 호출할 때"
            "사용할 수 있다.\n"
        </item>
        <item>
            "\n 또한 let 함수는 수신 객체가 null 이 아닐 때만 람다 본문을"
            "실행해야 하는 경우에 주로 사용한다. let 함수는 안전한 호출"
            "연산자(?.)와 함께 사용해서 null 값을 검사할 수 있다. ?."
            "연산자는 11.2 절에서 설명한다.\n"
        </item>
        <item>
            "\n\n\n\n4. run 함수\n\n"

            " run 함수는 이미 생성된 객체에 대해 어떤 값을 계산하거나 여러"
            "개의 지역변수 범위를 제한할 때 사용한다.\n"
        </item>
        <item>
            "\n\n\n\n5. also 함수\n\n"

            " also 함수는 수신 객체의 프로퍼티를 변경하지 않을 때 주로"
            "사용한다.\n"
        </item>
    </string-array>

    <string-array name="explanation_11_1">
        <item>
            " 코틀린에서는 null 이 될 수 있는 타입과 null 이 될 수 없는"
            "타입을 구분한다. 실행 시점에 NullPointerException 오류가"
            "발생해 프로그램이 중단될 가능성을 줄이고자 null 관련 문제를"
            "컴파일 시점에 해결하는 것이다. 변수의 타입 뒤에 ? 을 붙이면 그 타입이"
            "null 이 될 수 있는 타입이 되어 변수에 null 을 저장할 수 있다.\n"
        </item>
        <item>
            " 위의 예제에서 Int 뒤의 ? 을 붙여 Int? 타입으로 만들어서"
            "null 을 저장할 수 있게 되었다. 변수 y 처럼 변수를 생성하자마자"
            "타입 지정 없이 null 로 초기화하면 그 변수의 타입은 자동으로"
            "nothing? 이 된다. nothing 에 대해선 12.5 절에서 설명한다.\n"
            " null 이 될 수 있는 타입의 변수는 null 이 될 수 없는"
            "타입의 변수에 비해 수행할 수 있는 연산이 제한된다. 다음 함수를"
            "보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 strlen1 함수는 null 을 인자로 받을 수 없지만"
            "strlen2 함수는 null 을 인자로 받을 수 있다. strlen2 함수는"
            "strlen1 함수와 달리 length 프로퍼티를 직접 호출할 수 없다."
            "그 이유는 문자열이 아닌 null 을 인자로 받을 경우 오류가 발생할"
            "수 있기 때문이다. 이런 경우 해당 인자가 null 인지 확인해야 한다.\n"
        </item>
        <item>
            " 위처럼 null 인지 확인하는 방법도 있지만 안전한 호출 연산자(?.)"
            "을 사용하면 더 간략하게 표현할 수 있다. 이에 대해선 다음 절에서"
            "설명한다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_11_2">
        <item>
            " null 이 될 수 있는 타입의 변수는 null 이 될 수 없는 타입의"
            "변수에 비해 수행할 수 있는 연산이 제한된다. 이는 null 이 될 수"
            "없는 타입의 변수에 대해 호출할 수 있는 프로퍼티나 메소드를,"
            "null 이 될 수 있는 타입의 변수에 저장된 값이 null 이 아닐 때는"
            "호출할 수 있지만 null 일 때는 호출할 수 없기 때문이다. 이런"
            "경우 null 이 될 수 있는 타입의 변수는 null 검사를 해야"
            "프로퍼티나 메소드를 호출할 수 있다. 이를 위해 코틀린에서는"
            "안전한 호출 연산자(?.)를 제공한다. 안전한 호출 연산자(?.)를"
            "사용하면 null 검사와 프로퍼티 또는 메소드 호출을 한 번에"
            "할 수 있다.\n"
        </item>
        <item>
            "\n 위의 예제처럼 안전한 호출 연산자(?.)를 null 이 아닌 값에 대해"
            "사용하면 일반적인 프로퍼티 또는 메소드 호출과 동일하다. null 에"
            "대해서 사용하면 호출한 것은 무시되고 null 이 반환된다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_11_3">
        <item>
            " 엘비스 연산자(?:)를 사용하면 null 값 대신 사용할 디폴트 값을"
            "지정할 수 있다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 null 이 아닌 값은 그대로 출력하였고, null 에"
            "대해서는 디폴트 값인 0 을 출력하였다. ?: 연산자는 ?: 을 기준으로"
            "앞에 있는 값이 null 이 아니면 앞의 값을, null 이면 뒤의 값을"
            "반환한다. 예를 들어, A ?: B 에 대해 A 가 null 이 아니면"
            "A 을, A 가 null 이면 B 을 반환한다.\n"
            " 엘비스 연산자는 안전한 호출 연산자와 함께 사용되는 경우가 많다."
            "안전한 호출 연산자를 null 에 대해 호출하면 null 이 반환되므로"
            "이 반환된 null 값 대신 엘비스 연산자로 지정한 디폴트 값으로"
            "대체할 수 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_11_4">
        <item>
            " 코틀린에서는 is 연산자를 사용하면 스마트 캐스트가 적용되어 자동으로"
            "타입을 변경할 수 있다.\n"
        </item>
        <item>
            " 위의 예제처럼 스마트 캐스트를 이용할 수 있지만 캐스트 연산자 as 을"
            "사용하여 명시적으로 타입 캐스팅 할 수 있다.\n"
        </item>
        <item>
            " 위의 코드는 겉보기에는 큰 문제가 없어 보이지만 실제로는 오류가 발생할"
            "가능성이 있다. as 연산자를 사용할 때 타입 캐스팅하려는 대상의"
            "타입을 변경할 수 없는 경우 ClassCaseException 이 발생한다.\n"
        </item>
        <item>
            "\n as? 연산자를 사용하면 타입 캐스팅이 가능할 경우 지정된 타입으로"
            "변경하지만 타입 캐스팅이 실패할 경우 null 을 반환한다. as?"
            "연산자는 ?: 연산자와 함께 사용되는 경우가 많다. ?: 뒤에 return"
            "을 작성하여 타입 캐스팅이 실패하여 null 이 반환되는 것을 대비할"
            "수 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_11_5">
        <item>
            " !! 연산자를 사용하면 null 이 될 수 있는 변수의 타입을 강제로"
            "null 이 될 수 없는 타입으로 변경할 수 있다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 str1 와 str2 는 null 이 될 수 있는"
            "타입의 변수이므로 프로퍼티나 메소드를 호출할 때 반드시 null"
            "검사를 해야 한다. str1 의 경우 프로퍼티와 메소드를 호출할 때"
            "모두 ?. 연산자를 호출하였다. 반면에, str2 의 경우 length"
            "프로퍼티를 호출하기 전에 !! 연산자를 사용해서 str2 의 값이"
            "null 이 아님을 단언하여 null 이 될 수 없는 타입으로"
            "변경하였다. 즉, !! 연산자를 사용한 순간부터 str2 의 타입은"
            "String 으로 변경된 것이다. 따라서 !! 연산자를 사용한 이후"
            "프로퍼티와 메소드를 호출할 때 일반적인 호출 방법을 사용하였다.\n"
            " !! 연산자는 null 이 될 수 있는 타입의 변수에 저장된 값이"
            "null 이 아닌 경우에만 타입을 변경한다. 만약 null 인 경우에는"
            "NullPointerException 을 발생시킨다.\n"
        </item>
        <item>
            "\n 위의 예제처럼 null 에 대해 !! 연산자를 사용하면"
            "NullPointerException 이 발생한다. 따라서 !! 연산자를"
            "사용할 경우 반드시 null 이 아닌 값에 사용해야 한다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_11_6">
        <item>
            " let 함수와 ?. 연산자를 함께 사용하면 null 이 아닌 값에"
            "대해서만 람다 식을 실행한다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제의 strInfo 함수에서 let 함수와 ?. 연산자를"
            "함께 사용하여 str 이 null 이 아닐 때만 람다 식이 실행되도록"
            "작성하였다. let 함수와 ?. 연산자를 함께 사용하면 수신 객체를"
            "람다 식 내에서 null 이 될 수 없는 타입의 변수처럼 사용할 수"
            "있다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_11_7">
        <item>
            " 일반적으로 클래스 내의 프로퍼티는 생성자 내에서 초기화해야 하며,"
            "생성자가 아닌 메소드 내에서는 초기화할 수 없다. 하지만 안드로이드에서"
            "액티비티(Activity) 인스턴스를 생성한 다음 onCreate() 에서"
            "초기화하는 것처럼, 객체 인스턴스를 일단 생성해놓고 나중에 초기화해야"
            "하는 경우가 있다. 프로퍼티를 선언해놓고 생성자가 아닌 메소드에서 초기화하는"
            "방법을 생각한다면 null 이 될 수 있는 타입을 떠올릴 수 있을 것이다."
            "다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 item 프로퍼티를 Item? 타입의 var 프로퍼티로"
            "선언한 다음 null 로 초기화하였다. 그리고 getItem 메소드에서"
            "Item 객체를 지정하였다.\n"
            " 위의 예제처럼 null 이 될 수 있는 타입을 사용할 수 있긴 하지만,"
            "모든 프로퍼티 접근에 null 검사를 하거나 ?. 연산자를 사용하거나,"
            "!! 연산자를 사용해야 하는 문제점이 있다. 이에 대한 해결 방법으로"
            "lateinit 키워드를 사용하는 방법이 있다. lateinit 키워드를"
            "사용하면 해당 프로퍼티를 생성자가 아닌 곳에서 초기화할 수 있다.\n"
        </item>
        <item>
            "\n\n lateinit 키워드를 사용하는 프로퍼티는 반드시 var 프로퍼티로"
            "선언되어야 한다. val 프로퍼티는 기본적으로 final 이며,"
            "생성자 내에서 초기화되어야 한다. 따라서 생성자가 아닌 메소드 내에서"
            "초기화되어야 하는 lateinit 프로퍼티는 반드시 var 로 선언되어야"
            "한다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_11_8">
        <item>
            " null 이 될 수 없는 타입의 변수에서 호출할 수 있는 프로퍼티나"
            "메소드를, null 이 될 수 있는 타입의 변수에서 호출할 경우 null"
            "검사를 해야함을 11.2 절에서 확인하였다. 하지만 null 이 될 수"
            "있는 타입에 대한 확장 프로퍼티나 함수는 null 검사를 하지 않고도"
            "사용할 수 있다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 str1 와 str2 은 모두 String? 타입의"
            "변수이지만, null 검사를 하지 않고 isNullOrEmpty() 을"
            "호출하였다. 이는 isNullOrEmpty() 가 String? 에 대한"
            "확장 함수이기 때문이다. 코틀린에서는 null 이 될 수 있는 타입에"
            "대한 확장 프로퍼티나 함수는 null 검사 없이도 호출할 수 있다."
            "이에 대해선 사용자가 직접 정의한 확장 프로퍼티와 함수에도 유효하다."
            "다음은 null 이 될 수 있는 타입을 확장한 예제이다.\n"
        </item>
        <item>
            "\n 위의 예제에서 String? 타입에 대한 확장 프로퍼티 len 을"
            "정의하였다. null 이 될 수 있는 타입에 대해 확장한 것이기"
            "때문에, null 검사를 하지 않고도 사용할 수 있다. 또한 null"
            "이 될 수 있는 타입에 대해 확장한 함수나 프로퍼티는, null 이"
            "될 수 없는 타입의 변수에서도 호출할 수 있다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_12_1">
        <item>
            " 자바의 래퍼 클래스(Wrapper Class)는 원시 타입의 값을"
            "객체로 표현하기 위해 사용된다. 자바에서는 원시 타입의 값을"
            "데이터로 갖는 컬렉션 객체를 생성할 때 래퍼 클래스를 주로 사용된다."
            "자바와 달리 코틀린에서는 원시 타입과 래퍼 클래스를 구분하지 않는다."
            "따라서 코틀린에서 컬렉션을 생성할 때 같은 타입을 사용한다.\n\n\n\n"



            "1. Java 코드\n"
        </item>
        <item>
            "2. Kotlin 코드\n"
        </item>
    </string-array>

    <string-array name="explanation_12_2">
        <item>
            " 코틀린에서는 자바와 달리 숫자 타입의 자동 변환이 이루어지지 않는다."
            "자바에서는 실수 타입 변수에 정수 값을 대입하면 자동으로 실수 타입으로"
            "변환되지만, 코틀린에서는 그렇지 않다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 실수 타입 변수에 정수 값을 대입하려고 시도하였지만"
            "오류가 발생하였다. 이처럼 코틀린에서는 숫자 타입의 변환이 자동으로"
            "이루어지지 않는다. 대신 타입 변환을 직접 실시해야 한다.\n"
        </item>
        <item>
            "\n 코틀린의 원시 타입은 명시적으로 다른 원시 타입으로 변환할 수 있다."
            "범위가 좁은 타입에서 넓은 타입으로 변환할 수 있고, 반대로 넓은 타입에서"
            "좁은 타입으로 변환할 수 있다. 넓은 타입에서 좁은 타입으로 변환하는"
            "경우 값의 일부가 소실될 수 있다. 변환 함수 이름은 모두 to[변환하려는 타입]"
            "으로 되어 있다. 예를 들어, Int 타입을 Double 타입으로 변경하는"
            "함수는 toDouble 함수이다. 다음은 타입 변환 예제이다.\n"
        </item>
        <item>
            "\n 만약 타입 변환에 실패하였을 경우 오류가 발생한다. 타입 변환에"
            "실패하는 경우로는 문자열을 숫자 타입으로 변환하는 경우가 있다.\n"
        </item>
        <item>
            "\n 숫자 타입 변수에 타입이 다른 숫자를 대입하려는 경우, 숫자 리터럴을"
            "사용하면 변환 함수를 호출하지 않아도 된다. 숫자 뒤에 f 또는 F"
            "접미사를 붙이면 Float 타입, L 을 붙이면 Long 타입이 된다.\n"
        </item>
    </string-array>

    <string-array name="explanation_12_3">
        <item>
            " 코틀린의 Any 타입은 모든 원시 타입과 참조 타입에 대한 최상위"
            "타입이다. Any 타입의 변수는 모든 타입의 값을 저장할 수 있다."
            "null 까지 저장하려면 Any? 타입으로 선언하면 된다.\n"
        </item>
        <item>
            "\n 참고로 모든 클래스는 toString, equals, hashCode"
            "메소드를 구현해야 하는데, Any 타입은 참조 타입에 대한 최상위"
            "타입이다. 따라서 이 세 가지 메소드는 Any 타입에서 정의되어 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_12_4">
        <item>
            " 코틀린의 모든 함수는 반환 타입이 존재한다. 식이 본문인 함수는"
            "반환 타입을 생략할 수 있지만, 블록이 본문인 함수는 반환 타입을"
            "생략할 수 없다. 하지만 함수의 반환 타입이 Unit 일 경우 반환 타입을"
            "명시하지 않아도 된다.\n"
        </item>
        <item>
            "\n 코틀린의 Unit 타입은 자바의 void 타입과 거의 같다."
            "자바의 void 타입처럼, 어떤 값도 반환하지 않을 때 사용한다."
            "단, 어떤 값도 반환하지 않는다는 의미이지, 반환 행위가 이루어지지"
            "않는다는 것을 의미하지는 않는다. 코틀린 컴파일러는 반환 타입이"
            "Unit 타입인 함수에 묵시적으로 return Unit 을 넣어준다."
            "또한 자바의 void 타입과 다른 점은, 코틀린의 Unit 타입은 제네릭"
            "파라미터의 인자로 넘길 수 있다는 점이다."
        </item>
        <item>
            "\n 제네릭 타입 파라미터에 대해선 [15. 제네릭스] 에서 설명한다.\n"
            " 또한 코틀린의 Unit 은 싱글턴에 해당하며, Any 타입의 서브"
            "클래스에 해당한다.\n"
        </item>
    </string-array>

    <string-array name="explanation_12_5">
        <item>
            " Nothing 타입은 Unit 타입과 마찬가지로 반환 값이 존재하지"
            "않음을 의미한다. Unit 타입과 다른 점은, Unit 타입은"
            "반환 값이 존재하지 않을 뿐이지 반환 행위는 존재하지만,"
            "Nothing 타입은 반환 값도 없고 반환 행위도 존재하지 않는다."
            "반환 행위가 존재하지 않는다는 것은 함수가 정상적으로 끝나지 않는다는"
            "의미이다. 이런 경우는 함수가 예외를 발생시키거나, 함수 내의 무한"
            "루프가 도는 경우이다.\n"
        </item>
        <item>
            "\n 위의 예제처럼 코틀린의 Nothing 타입은 반환하는 값도 없고,"
            "반환 행위가 존재하지 않을 때 사용된다. 따라서 Nothing 타입은"
            "함수의 반환 타입으로만 사용된다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_13_1">
        <item>
            " 코틀린에서는 연산자에 대한 오버로딩을 제공한다. 연산자 오버로딩은"
            "멤버 함수로 정의하거나 확장 함수로 정의할 수 있다. 연산자 오버로딩을"
            "구현하려면 operator 키워드를 사용해야 한다. 연산자 오버로딩을"
            "구현한 예제는 다음과 같다.\n"
        </item>
        <item>
            "\n 위의 예제에서 Point 객체에 대해 + 연산자에 대한 오버로딩을"
            "멤버 함수로 정의하였고, - 연산자에 대한 오버로딩을 확장 함수로"
            "정의하였다. operator 키워드는 연산자 오버로딩을 구현할 때"
            "사용한다. 또한 plus 함수는 + 연산자에 대한 오버로딩을, minus"
            "함수는 - 연산자에 대한 오버로딩을 구현하기 위해 사용하는 함수"
            "이름이다. 코틀린에서는 특정 언어 기능과 함수 이름을 연결하는 것을"
            "관례(Convention)라고 한다. 특정 연산자에 대해 오버로딩을"
            "구현하려면 특정한 함수 이름을 사용해야 한다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_13_2">
        <item>
            "1. 이항 산술 연산자 오버로딩\n"
        </item>
        <item>
            "\n 위의 표는 오버로딩할 수 있는 이항 산술 연산자의 종류를 나타내는"
            "표이다. 이항 산술 연산자를 오버로딩한 예제는 다음과 같다.\n"
        </item>
        <item>
            "\n 연산자를 오버로딩하더라도 연산자 우선 순위는 변하지 않는다. 따라서"
            "*, /, % 연산자는 모두 우선 순위가 동일하며, + 와 - 연산자보다 우선"
            "순위가 높다.\n"
            " 또한 두 피연산자의 타입은 동일하지 않아도 된다. 따라서 아래 코드도"
            "유효하다.\n"
        </item>
        <item>
            "\n\n\n\n"
            "2. 복합 대입 연산자 오버로딩\n\n"

            " 복합 대입 연산자는 += 와 같이 대입 연산과 산술 연산을 합친"
            "연산자이다. 오버로딩할 수 있는 복합 대입 연산자의 종류는 다음과"
            "같다.\n"
        </item>
        <item>
            " 복합 대입 연산자를 오버로딩할 경우 반환 타입은 반드시 Unit"
            "타입이 되어야 한다. 따라서 복합 대입 연산자는 기존 객체의 내부"
            "상태를 변경할 때 사용한다.\n"
        </item>
        <item>
            "\n\n\n\n"
            "3. 단항 연산자 오버로딩\n"
        </item>
    </string-array>

    <string-array name="explanation_13_3">
        <item>
            "1. equals 메소드\n\n"

            " 코틀린에서 == 연산자 호출은 equals 메소드 호출로 컴파일된다."
            "따라서 equals 메소드를 오버로딩하면 == 연산자 오버로딩을"
            "할 수 있다. == 연산자를 오버로딩한 예제는 다음과 같다.\n"
        </item>
        <item>
            "\n 위의 예제에서 equals 메소드 앞에는 operator 키워드가 없고"
            "override 키워드가 붙어 있다. 이는 equals 메소드가"
            "Any 에 구현되어 있기 때문에 override 키워드가 붙은 것이며,"
            "Any 에서 구현한 equals 메소드 앞에는 operator 키워드가"
            "붙어 있기 때문에 equals 메소드를 오버로딩할 때 operator"
            "키워드를 붙이지 않아도 자동으로 operator 키워드가 적용된다.\n"
            " 또한 equals 메소드는 확장 함수로 정의할 수 없다. 이는"
            "Any 의 equals 메소드가 확장 함수로 정의한 equals 메소드보다"
            "우선 순위가 높기 때문이다.\n\n\n\n"



            "2. compareTo 메소드\n\n"

            " &lt;, &gt;, &lt;=, &gt;= 와 같은 비교 연산자는"
            "compareTo 메소드 호출로 컴파일된다. compareTo 메소드는"
            "Comparable 인터페이스 내에 존재한다. 따라서 위의 비교 연산자를"
            "오버로딩하려면 Comparable 인터페이스를 구현해야 한다.\n"
        </item>
        <item>
            "\n equals 메소드와 마찬가지로 Comparable 인터페이스 내의"
            "compareTo 메소드에 operator 키워드가 붙어 있다. 따라서"
            "compareTo 메소드를 오버로딩할 때 operator 키워드를 붙이지"
            "않아도 된다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_13_4">
        <item>
            " 코틀린에서 [ ] 와 인덱스를 통해 객체 내의 원소에 접근하는 것은"
            "get 메소드 또는 set 메소드 호출로 연결된다. 객체 내의 원소를"
            "읽으면 get 메소드가, 원소를 추가하거나 변경하면 set 메소드가"
            "호출된다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 [ ] 와 인덱스를 통해 get 메소드와 set 메소드를"
            "호출하였음을 확인할 수 있다. 참고로 get 메소드의 인덱스로 정수뿐만"
            "아니라 다른 타입도 사용할 수 있다. Map 객체의 키로 정수뿐만 아니라"
            "다른 타입을 사용할 수 있는 것처럼, get 메소드의 인덱스 타입으로"
            "임의의 타입을 사용할 수 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_13_5">
        <item>
            " in 연산자는 특정 값이 객체 내에 존재하는지 확인한다. in 연산자를"
            "오버로딩하려면 contains 메소드를 오버로딩하면 된다.\n"
        </item>
    </string-array>

    <string-array name="explanation_14_1">
        <item>
            " 고차 함수란 다른 함수를 인자로 받거나 함수를 반환하는 함수이다."
            "인자로 받는 함수나 반환되는 함수는 람다로 표현된다. 이 때 람다의"
            "타입을 함수 타입이라 말한다. 고차 함수를 정의하는 방법을 알기 위해"
            "먼저 함수 타입이 무엇인지 알아야 한다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 (Int, Int) -> Int 부분이 함수 타입이다."
            "화살표를 기준으로 왼쪽에는 파라미터 타입을 괄호 안에 넣어 작성하고,"
            "오른쪽에는 람다의 결과 타입을 작성한다. 일반 함수에서는 반환 타입이"
            "Unit 타입일 경우 생략해도 되지만, 함수 타입을 작성할 때 반환"
            "타입이 Unit 타입일 경우 반드시 작성해야 한다.\n"
        </item>
        <item>
            "\n 다른 변수와 마찬가지로 함수 타입 변수도 null 이 될 수 있다."
            "null 이 될 수 있는 함수 타입 변수를 선언하는 방법은 다음과 같다.\n"
        </item>
    </string-array>

    <string-array name="explanation_14_2">
        <item>
            " 14.1 절에서 알아본 함수 타입을 사용하는 방법을 이용해서 고차"
            "함수를 정의할 수 있다. 이번 절에서는 다른 함수를 인자로 받는 고차"
            "함수를 정의하는 알아보자. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제는 사칙연산에 해당하는 함수를 인자로 받는 고차 함수를"
            "나타낸다. operation 이라는 함수를 인자로 받는 파라미터를"
            "선언하였고, 함수 본문 내에서 함수 타입 파라미터를 호출하였다."
            "파라미터의 이름 뒤에 함수 타입을 지정하면 함수를 인자로 받을 수 있으며,"
            "인자로 받는 함수를 호출하는 방법은 일반 함수를 호출하는 방법과"
            "동일하다.\n"
            " 함수 타입 파라미터도 디폴트 값을 지정할 수 있다. 디폴트 값을 갖는"
            "함수 타입 파라미터는 다음과 같이 작성할 수 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_14_3">
        <item>
            " 이번 절에서는 함수를 반환하는 고차 함수를 정의하는 방법을 알아보자."
            "다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제는 사칙연산의 연산자를 인자로 넘기면 두 개의 정수를 인자로"
            "받는 함수를 반환한다. 함수를 반환하는 고차 함수를 정의하려면 함수 타입을"
            "반환 타입으로 지정하면 된다. 함수를 호출함으로써 반환된 함수를 호출하는"
            "방법은 일반 함수를 호출하는 방법과 동일하다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_14_4">
        <item>
            " 코틀린에서는 람다를 사용할 때 람다가 변수를 포획하면 람다가 생성되는"
            "시점에 무명 클래스가 생성된다. 특히 람다를 사용하는 고차 함수의 경우,"
            "람다가 변수를 포획하면 함수를 호출할 때마다 람다가 생성되고 무명 클래스가"
            "생성되어 런타임 오버헤드(Runtime Overhead)를 초래할 수 있다."
            "코틀린 컴파일러는 inline 변경자를 제공하여 람다를 사용하는 고차"
            "함수를 인라인 함수로 정의하여 런타임 오버헤드를 줄일 수 있도록 한다."
            "먼저 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제처럼 fun 키워드 앞에 inline 변경자를 붙이면"
            "인라인 함수로 정의할 수 있다. 인라인 함수로 정의하면 함수를 호출하는"
            "부분을 함수 본문을 번역한 코드로 컴파일된다. 위의 함수를 인라인"
            "함수로 정의한 것과 일반 함수로 정의한 것을 비교해보자.\n"
        </item>
        <item>
            "\n 첫 번째 코드는 인라인 함수로 정의한 것을 decompile 한 것이며,"
            "두 번째 코드는 일반 함수로 정의한 것을 decompile 한 것이다."
            "위의 두 코드를 비교하면 인라인 함수로 정의했을 때, 일반 함수로"
            "정의했을 때 함수를 호출했던 부분을 함수 본문을 번역한 코드로"
            "컴파일한다는 것을 알 수 있다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_14_5">
        <item>
            " 14.4 절에서 인라인 함수를 사용하면 람다 사용으로 발생하는"
            "런타임 오버헤드를 줄일 수 있음을 확인하였다. 그러나 람다를 사용하는"
            "모든 함수를 인라이닝할 수는 없다. 일반적으로 인라인 함수 본문 내에서"
            "람다 식을 바로 호출하거나 람다 식을 인자로 받아 바로 호출하는 경우에는"
            "인라이닝이 가능하지만, 인자로 받은 람다를 다른 변수에 저장하고"
            "나중에 사용하는 경우 인라이닝이 불가능하다.\n"
        </item>
        <item>
            "\n 위의 코드에서 확인할 수 있듯이, 인자로 받은 람다를 인라인 함수"
            "본문 내에서 변수에 저장하려고 시도하면 오류가 발생한다. 위의 예제처럼"
            "인라이닝할 필요가 없는 람다만 인자로 받으면 그 함수를 일반 함수로"
            "정의하면 되지만, 일부 람다를 인라이닝할 필요가 있는 경우, 함수를"
            "인라인 함수로 정의하고 인라이닝하면 안되는 람다를 받는 인자 앞에"
            "noinline 변경자를 붙이면 된다.\n"
        </item>
    </string-array>

    <string-array name="explanation_14_6">
        <item>
            " 인라인 함수 본문 내에서 인자로 받은 람다를 다른 Context 안으로"
            "넘길 때 오류가 발생한다.\n"
        </item>
        <item>
            "\n 위와 같이 인자로 받은 람다를 다른 Context 내에서 실행하는"
            "경우 그 람다를 받는 인자 앞에 crossinline 변경자를 붙이면 된다.\n"
        </item>
    </string-array>

    <string-array name="explanation_15_1">
        <item>
            " 제네릭스는 컴파일 시점에 타입 체크를 하면서 다양한 타입의 객체를"
            "사용할 수 있게 허용하는 기능이다. 제네릭스를 사용하면 타입 파라미터를"
            "받는 타입을 정의할 수 있다. 타입 파라미터를 구체적인 타입 인자로"
            "치환하면 제네릭 타입의 인스턴스를 생성할 수 있다. 제네릭스를 사용하는"
            "예로 컬렉션이 있다. 컬렉션을 생성할 때는 그 컬렉션의 원소의 구체적인"
            "타입을 알아야 한다. 구체적인 타입을 넘기기 위해 클래스 이름 뒤에"
            "&lt; &gt; 을 붙이고 타입을 지정하면 된다.\n"
        </item>
        <item>
            "\n 코틀린 컴파일러는 일반 변수와 마찬가지로 타입 인자를 추론할 수"
            "있다. 따라서 원소가 존재하지 않는 빈 컬렉션이 아니면 타입 인자를"
            "생략할 수 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_15_2">
        <item>
            " 컬렉션과 관련된 라이브러리 함수의 대부분은 제네릭 함수이다. 이는"
            "컬렉션 관련 함수가 다양한 타입에 대해 호출이 가능해야 하기 때문이다."
            "제네릭 함수를 정의하는 방법을 알기 위해 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 제네릭 함수는 List 의 두 번째 원소를 반환하는 함수이다."
            "다양한 타입의 List 에 대해 호출할 수 있도록 허용하기 위해 타입"
            "파라미터 T 를 사용하였다. 제네릭 함수를 정의하려면 fun 키워드"
            "뒤에 &lt; &gt; 를 사용해 타입 파라미터를 선언하면 된다. 그리고"
            "제네릭 함수를 호출하려면 제네릭 함수를 호출할 때 함수 이름 뒤에"
            "타입 인자를 명시하면 된다. 다만 코틀린 컴파일러는 타입 추론을"
            "하므로 타입 인자를 명시하지 않고도 타입을 추론할 수 있으면 타입"
            "인자를 생략할 수 있다.\n"
            " 함수뿐만 아니라 확장 프로퍼티에도 제네릭 타입 파라미터를 사용할"
            "수 있다. 주의할 점으로 일반 클래스의 프로퍼티는 타입 파라미터를"
            "가질 수 없으므로 제네릭하게 만들 수 없다. 일반 클래스의 경우 확장"
            "프로퍼티만 제네릭하게 만들 수 있다. 클래스 내의 프로퍼티를 제네릭하게"
            "만들려먼 제네릭 클래스를 사용해야 한다.\n"
        </item>
    </string-array>

    <string-array name="explanation_15_3">
        <item>
            " 제네릭 클래스를 사용하려면 클래스 이름 뒤에 &lt; &gt; 를"
            "사용해서 타입 파라미터를 선언하면 된다. 제네릭 클래스를 사용하면"
            "클래스 내에서 타입 파라미터를 일반적인 타입처럼 사용할 수 있다.\n"
        </item>
        <item>
            "\n 만약 제네릭 클래스를 확장하는 클래스를 정의한다면 그 제네릭 클래스의"
            "타입 파라미터에 대해 타입 인자를 지정해야 한다.\n"
        </item>
        <item>
            "\n 위의 예제처럼 제네릭 클래스를 확장할 때 그 제네릭 클래스의 타입"
            "파라미터로 구체적인 타입을 지정하거나 하위 클래스 자신의 타입 파라미터를"
            "지정해야 한다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_15_4">
        <item>
            " 타입 파라미터 제약이란 타입 파라미터로 받을 인자의 타입을 제한하는"
            "기능이다. 타입 파라미터 제약이 필요한 이유를 알아보기 위해 먼저"
            "다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제는 정수나 실수의 값을 절반으로 나누는 함수이다. 위의 함수는"
            "Int 나 Double 과 같은 숫자에는 유효하지만, 문자나 문자열에는"
            "적용할 수 없다. 따라서 문자나 문자열을 인자로 받을 가능성이 있기"
            "때문에 위의 함수에서 toDouble 함수를 호출하는 부분에서 오류가"
            "발생한 것이다.\n"
            " 위의 상황에서 타입 파라미터로 넘길 인자의 타입을 숫자로 제한한다면"
            "오류가 발생하지 않을 것이다. 이런 기능이 바로 타입 파라미터 제약"
            "기능이다. 타입 파라미터 이름 뒤에 콜론(:)을 붙이고 그 뒤에 특정"
            "타입을 지정하면 타입의 상한을 지정할 수 있다.\n"
        </item>
        <item>
            "\n 위의 예제에서 타입 파라미터의 상한을 Number 으로 제한하였다."
            "따라서 문자나 문자열을 인자로 받을 수 없으므로 오류가 발생하지"
            "않는다.\n"
            " 타입 파라미터 제약을 두 번 이상 가해야 할 경우 제약을 가하는"
            "방식이 조금 다르다. 두 번 이상 제약을 가하기 위해선 반환 타입 뒤에"
            "where 키워드를 사용한 다음 타입 파라미터에 제약을 가하면 된다."
            "두 번 이상 제약을 가하는 방법은 다음과 같다.\n"
        </item>
        <item>
            "\n 한편, 제약을 가하지 않은 타입 파라미터는 T: Any? 와 동일하다."
            "즉, 해당 타입 파라미터는 null 이 될 수 있다. 타입 파라미터가"
            "null 이 될 수 없으면서 모든 타입의 인자를 받을 수 있게 하려면"
            "T: Any 로 제약을 가하면 된다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_15_5">
        <item>
            " 타입 파라미터와 is 을 사용해서 특정 값의 타입을 검사하려고"
            "시도하면 오류가 발생한다. 이는 실행 시점에 제네릭 타입 인자의"
            "정보가 지워지기 때문이다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 함수는 인자로 넘긴 값이 타입 파라미터 인자의 타입과 동일한지"
            "확인하는 함수이다. 겉보기에는 코드에 문제가 없어 보이지만, 실제로는"
            "실행 시점에 타입 파라미터로 넘긴 인자에 대한 정보가 지워지기 때문에"
            "타입 검사를 할 수 없다. 마찬가지로 제네릭 타입 인자 정보가 지워지기"
            "때문에 타입 변환도 불가능하다.\n"
            " 반면에 타입 파라미터가 아닌 구체적인 타입을 사용하면 is 검사를"
            "문제없이 수행할 수 있다.\n"
        </item>
        <item>
            "\n 실행 시점에 제네릭 타입 인자의 정보를 알기 위해서는 함수를 인라인"
            "함수로 정의하고 타입 파라미터의 이름 앞에 reified 를 붙이면 된다."
            "이에 대해선 다음 절에서 설명한다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_15_6">
        <item>
            " 15.5 절에서 실행 시점에 제네릭 타입 인자의 정보가 지워진다는 것을"
            "알아보았다. 실행 시점에 제네릭 타입 인자의 정보을 알기 위한 방법으로"
            "함수를 인라인 함수로 정의하고, 타입 파라미터 이름 앞에 reified 를"
            "붙이는 방법이 있다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 함수를 인라인 함수로 정의하고, 타입 파라미터 T 앞에"
            "reified 를 붙여 실행 시점에 제네릭 타입 인자의 정보를 알 수 있게"
            "하였다. reified 키워드는 해당 타입 파라미터가 실행 시점에 지워지기"
            "않도록 하는 키워드이다. 인라인 함수에서 reified 키워드가 붙은"
            "타입 파라미터만 실행 시점에 지워지지 않으며, reified 키워드가 붙지"
            "않은 타입 파라미터는 여전히 실행 시점에 지워진다.\n"
            " 주의할 점으로 reified 키워드는 인라인 함수 내에서만 사용할"
            "수 있다. 인라인 함수가 아닌 함수에서는 reified 키워드를"
            "사용할 수 없다. 즉, 함수의 성능을 향상시키려는 것이 아니라 reified"
            "키워드를 사용하기 위해서 인라인 함수를 사용하는 것이다. 또한"
            "reified 키워드가 붙은 타입 파라미터를 사용해서 클래스의 인스턴스를"
            "생성하거나, 동반 객체의 메소드를 호출할 수 없다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_15_7">
        <item>
            " 변성(Variance)이란 List&lt;Any&gt;"
            "와 List&lt;Int&gt; 와 같이 타입 인자가 다르면서 같은 객체"
            "사이의 관계를 설명하는 개념이다. 이번 절에서는 무공변성(Invariance)에"
            "대해 알아본다. 무공변성이란 상속 관계와 상관없이 자신의 타입만을"
            "허용하는 것을 의미한다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 클래스 A 는 클래스 B 의 상위 타입에 해당한다."
            "반대로 말하면 클래스 B 는 클래스 A 의 하위 타입이다. 위의 예제의"
            "함수는 A 타입의 변수를 인자로 받으므로 A 의 하위 타입인 B 타입의"
            "변수를 인자로 넘길 수 있다. 반면에, List&lt;A&gt; 와"
            "List&lt;B&gt; 사이의 관계는 위와 같은 상위-하위 타입 관계가"
            "성립하지 않는다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 알 수 있듯이, A 와 B 사이의 관계는"
            "MutableList&lt;A&gt; 와 MutableList&lt;B&gt; 사이에서는"
            "성립하지 않는다. 이러한 관계를 무공변성이라고 한다. 따라서"
            "위의 함수의 인자로 오직 MutableList&lt;A&gt; 타입의"
            "변수만 넘길 수 있다.\n\n"
        </item>
    </string-array>

    <string-array name="explanation_15_8">
        <item>
            " 15.7 절에서 타입 A 와 B 의 관계는 제네릭 클래스 사이에서는"
            "성립하지 않는다는 것을 확인하였다. 하지만 타입 파라미터 이름 앞에"
            "out 을 넣으면 제네릭 클래스 사이에서도 해당 관계가 성립한다."
            "이를 공변성(Covariance)이라고 한다. 다음 예제를 보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 알 수 있듯이, 타입 파라미터 이름 앞에 out"
            "을 넣으면 타입 A 와 B 사이의 관계가 제네릭 클래스 사이에서도"
            "유지된다. 따라서 MyType&lt;B&gt; 타입은 MyType&lt;A&gt; 의 하위 타입이 되며,"
            "MyType&lt;A&gt; 타입을 인자로 받는 파라미터에 인자로"
            "넘길 수 있다.\n"
            " 위에서 사용한 out 은 해당 타입 파라미터가 공변적임을 나타낸다."
            "여기서 out 이 붙은 공변적 파라미터는 항상 아웃(out) 위치에"
            "있어야 한다. 타입 파라미터가 함수의 반환 타입에 사용된다면 그"
            "타입 파라미터는 아웃(out) 위치에 존재한다. 반면에 타입 파라미터가"
            "함수의 파라미터 타입에 사용된다면 그 타입 파라미터는 인(in)"
            "위치에 존재한다. out 으로 선언된 타입 파라미터는 오직 반환 타입으로만"
            "사용될 수 있기 때문에, 클래스가 out 으로 선언된 제네릭 타입의"
            "값을 생산할 수 있지만 소비할 수는 없다. 즉, out 은 해당 타입"
            "파라미터가 공변적이며, 아웃 위치에서만 사용될 수 있다는 의미이다.\n"
        </item>
        <item>
            "\n 위의 예제에서 알 수 있듯이, out 으로 선언된 타입 파라미터"
            "T 는 함수의 반환 타입으로 사용될 수 있지만, 함수의 파라미터"
            "타입으로는 사용될 수 없다. 주의할 점으로 타입 파라미터를 생성자"
            "프로퍼티의 타입으로 사용할 때이다. 게터는 값을 반환하므로 out 에"
            "해당하며, 세터는 값을 인자로 받으므로 in 에 해당한다. val 로"
            "선언된 프로퍼티는 세터 없이 게터만 정의하는 것과 같으므로 아웃"
            "위치에 해당하고, var 로 선언된 프로퍼티는 게터와 세터를 정의하는"
            "것과 같으므로 인 위치와 아웃 위치 동시에 해당한다. 따라서 out"
            "으로 선언한 타입 파라미터는 오직 val 로 선언한 프로퍼티의 타입으로만"
            "사용될 수 있다.\n"
        </item>
    </string-array>

    <string-array name="explanation_15_9">
        <item>
            " 반공변성(Contravariance)은 공변성의 반대이다. 타입 A 와"
            "B 에 대해서 A 가 B 의 상위 타입일 경우, 제네릭 클래스 사이에서"
            "관계가 역전될 경우 이를 반공변성이라고 한다. 타입 파라미터 이름"
            "앞에 in 을 넣으면 반공변적 파라미터로 만들 수 있다. 다음 예제를"
            "보자.\n"
        </item>
        <item>
            "\n 위의 예제에서 알 수 있듯이, 타입 파라미터 이름 앞에 in 을"
            "넣으면 타입 A 와 B 사이의 관계가 제네릭 클래스 사이에서 역전된다."
            "따라서 MyType&lt;A&gt; 타입은 MyType&lt;B&gt; 타입의 하위"
            "타입이 되며, MyType&lt;B&gt; 타입을 인자로 받는 파라미터에"
            "인자로 넘길 수 있다.\n"
            " 위에서 사용한 in 은 해당 타입 파라미터가 반공변적임을 나타낸다."
            "여기서 in 이 붙은 반공변적 파라미터는 항상 인(in) 위치에"
            "있어야 한다. 타입 파라미터가 함수의 파라미터 타입에 사용된다면"
            "그 타입 파라미터는 인(in) 위치에 존재한다. in 으로 선언된"
            "타입 파라미터는 오직 함수 파라미터의 타입으로만 사용될 수 있기"
            "때문에, 클래스가 in 으로 선언된 제네릭 타입의 값을 소비할 수"
            "있지만 생산할 수는 없다. 즉 in 은 해당 타입 파라미터가 반공변적이며,"
            "인 위치에서만 사용될 수 있다는 의미이다.\n"
        </item>
        <item>
            "\n 위의 예제에서 알 수 있듯이, in 으로 선언된 타입 파라미터"
            "T 는 함수의 파라미터 타입으로는 사용될 수 있지만, 함수의 반환"
            "타입으로는 사용될 수 없다. 15.8 절에서 확인하였듯이, val"
            "로 선언된 프로퍼티는 세터 없이 게터만 정의하는 것과 같으므로 아웃"
            "위치에 해당하고, var 로 선언된 프로퍼티는 게터와 세터를 정의하는"
            "것과 같으므로 인 위치와 아웃 위치 동시에 해당한다. 따라서 in"
            "으로 선언된 타입 파라미터는 프로퍼티의 타입으로 사용될 수 없다.\n"
        </item>
    </string-array>

    <string name="display_header">디스플레이</string>
    <string name="text_size_title">글자 크기</string>
    <string-array name="text_sizes">
        <item>작게</item>
        <item>중간</item>
        <item>크게</item>
    </string-array>
    <string-array name="text_sizes_values">
        <item>small</item>
        <item>middle</item>
        <item>large</item>
    </string-array>
</resources>